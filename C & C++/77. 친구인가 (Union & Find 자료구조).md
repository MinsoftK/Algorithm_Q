# 77. 친구인가 (Union & Find 자료구조)

* 오늘은 새 학기 새로운 반에서 처음 시작하는 날이다. 현수네 반 학생은 N명이다. 현수는 각 학생들의 친구관계를 알고 싶다.
모든 학생은 1부터 N까지 번호가 부여되어 있고, 현수에게는 각각 두 명의 학생은 친구 관계가 번호로 표현된 숫자쌍이 주어진다. 만약 (1, 2), (2, 3), (3, 4)의 숫자쌍이 주어지면 1번 학생과 2번 학생이 친구이고, 2번 학생과 3번 학생이 친구, 3번 학생과 4번 학생이 친구이다. 
그리고 1번 학생과 4번 학생은 2번과 3번을 통해서 친구관계가 된다.
학생의 친구관계를 나타내는 숫자쌍이 주어지면 특정 두 명이 친구인지를 판별하는 프로그램
을 작성하세요. 두 학생이 친구이면 “YES"이고, 아니면 ”NO"를 출력한다.




<br/>
<br/>

#### ▣ 입력설명

* 첫 번째 줄에 반 학생수인 자연수 N(1<=N<=1,000)과 숫자쌍의 개수인 M(1<=M<=3,000)이 주어지고, 다음 M개의 줄에 걸쳐 숫자쌍이 주어진다. 
마지막 줄에는 두 학생이 친구인지 확인하는 숫자쌍이 주어진다.


#### ▣ 출력설명

* 첫 번째 줄에 “YES"또는 "NO"를 출력한다.




#### ▣ 입력예제 1
9 7  
1 2  
2 3  
3 4  
4 5  
6 7  
7 8  
8 9  
3 8  






#### ▣ 출력예제 1
NO

<br/>
<br/>


## 내가 짠 코드
*

<br/>

```c++


```


<br><br> 

## 풀이
* 이해하기 어려웠던 것이 disjoint-set이라는 개념 자체가 어려웠다. 
해당 개념은 [이곳](https://ratsgo.github.io/data%20structure&algorithm/2017/11/12/disjointset/)에서 자세한 설명을 찾을 수 있다. 읽고나니 알고리즘 자체라는 것을 이해했다. 재귀를 통해 부모 노드의 값을 자식 노드에 입력한다라고 생각하면 편하다.
<br/>

```c++
#include <iostream>
#include <stdio.h>>
using namespace std;
int unf[1001];

int Find(int v)
{
	if (unf[v] == v)
		return v;
	else return (unf[v] = Find(unf[v]); //배열에 넣고 return해준다. 
	//path compression 단계 
	
	//1~100명이 있다고 하면 99번의 재귀가 실행이 되기 때문에 굉장히 비효율적
	//따라서 경로압축을 해준다. unf[v]에 재귀의 값을 저장해줌으로써
	//하나의 레벨만 가지게 만들어줄 수 있다. 강의 20분 참고 
	//호출한 곳에다가 값만 주고 있다. 메모제이션 하듯이 인덱스에 저장을 한다.
	//1, 5일 경우를 생각하면
	// f(1)일때 unf[1] = f(2)
	//unf[2] = f(3) 
	//unf[3] = f(4) = 4 이기 때문에 4의 값이 재귀를 return하며
	//unf[1],[2],[3],[4]에 4값이 전부 저장된다. 
	//굉장히 이해하기는 어렵다. 
}

void Union(int a, int b)
{
	a = Find(a);
	b = Find(b);
	if (a != b) unf[a] = b;
}

int main()
{
	freopen("input.txt", "rt", stdin);
	int n, m, a, b, i;
	scanf("%d %d", &n, &m);
	for(i = 1; i <= n; i++)
	{
		unf[i]= i;
	}
	for (i = 1; i <= m; i++)
	{
		cin >> a >> b;
		Union(a, b);
	}
}



//69
/*
************ pair 부분 출력파트   ***********
 	for (i = 1; i <= m; i++)
	{
		for(j = 0; j < map[i].size(); j++)
		{
			printf("map[%d][%d] : %d \n", i, map[i][j].first, map[i][j].second);
		}
	}

*********************************************
*/

//36 삽입정렬 
//43, 44 이분검색 응용 
//51 다이나믹 
//56 재귀
//58 이진트리 깊이우선탐색 
//65 STL vector 생성방법 
//66 DFS 인접리스트 (벡터활용) 
//67 DFS 인접행렬 
//68 DFS 가중치 방향그래프 인접리스트 
//69 BFS 이진트리 넓이 우선탐색 
//70 BFS 그래프 최단거리 
//71 BFS 상태트리 검색 
//72 최대 Heap 구조와 유사하게 운영이되는  Priority_queue
//75 최대 수입 스케쥴
//76 이항계수 메모리제이션 
//77 disjoint-set
```
