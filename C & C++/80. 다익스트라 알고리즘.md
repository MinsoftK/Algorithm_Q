# 80. 다익스트라 알고리즘

- 아래의 가중치 방향그래프에서 1번 정점에서 모든 정점으로의 최소 거리비용을 출력하는 프로그램을 작성하세요. (경로가 없으면 Impossible를 출력한다)

![](https://github.com/MinsoftK/c-Algorithm_Q/blob/master/img/80.png?raw=true)

<br/>
<br/>

#### ▣ 입력설명

- 첫째 줄에는 정점의 수 N(1<=N<=20)와 간선의 수 M가 주어진다. 그 다음부터 M줄에 걸쳐 연결정보와 거리비용이 주어진다.

#### ▣ 출력설명

- 1번 정점에서 각 정점으로 가는 최소 간선수를 2번 정점부터 차례대로 출력하세요.

#### ▣ 입력예제 1

6 9  
1 2 12  
1 3 4  
2 1 2  
2 3 5  
2 5 5  
3 4 5  
4 2 2  
4 5 5  
6 4 5

#### ▣ 출력예제 1

2 : 11  
3 : 4  
4 : 9  
5 : 14  
6 : impossible

<br/>
<br/>

## 내가 짠 코드

-

<br/>

```c++


```

<br><br>

## 풀이

- 아 어렵당.... 여러가지 알고리즘들이 있는데 알고리즘간의 연산속도나 효율성을 비교하기가 어려운 것 같다. 큰 차이점을 아직은 느끼기가 힘든데 다익스트라 경우엔 초기값을 무한대로 설정한다는 것. 그 외엔 앞서했던 priority_Queue를

<br/>

```c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;

struct Edge {
	int vex;
	int dis;
	Edge(int a, int b)
	{
		vex = a;
		dis = b;
	}
	operator <(const Edge &b)
	{
		return dis > b.dis;
	}

};

int main()
{
	freopen("input.txt", "rt", stdin);
	int n, m, i;
	int a, b, c, res;
	vector<pair<int, int> > map[30];
	priority_queue<Edge> Q;
	scanf("%d %d", &n &m);
	vector<int> dist(n+1, 2147000000); //다익스트라 알고리즘은 초기값을 무한대로 설정
	for (i = 1; i <= m; i++)
	{
		scanf("%d %d %d", &a, &b, &c);
		map[a].push_back(b, c);
	}
	Q.push(Edge(1,0)); //우선 순위 queue에 넣는 이유는??
	//최소값을 가진 정점을 찾기 위해서
	dist[1] = 0;
	while (!Q.empty())
	{
		int now = Q.top().vex; //현재정점
		int cost = Q.top().dis; //정점까지의 최소비용
		//push된 값들이 최소힙구조로 있기 때문에 최소 비용을 가진 정점을 찾아서
		//now와 cost에 저장한다.
		Q.pop();
		if (cost > dist[now]) continue;
		for (i = 0; i < map[now].size(); i++)
		{
			int next = map[now][i].first;
			int	nextdis = cost + map[now][i].second;
			if (nextdis < dist[next])
			{
				dist[next] = nextdis;
				Q.push(Edge(next, nextdis));
			}
		}
	}
	for (i = 2; i <= n; i++)
	{
		if (dist[i] != 2147000000)
			cout<< i << " : "<<dist[i]<<endl;
		else cout<<i<< " : impossible"<<endl;
	}
	return (0);
}



//69
/*
************ pair 부분 출력파트   ***********
 	for (i = 1; i <= m; i++)
	{
		for(j = 0; j < map[i].size(); j++)
		{
			printf("map[%d][%d] : %d \n", i, map[i][j].first, map[i][j].second);
		}
	}

*********************************************
*/

//36 삽입정렬
//43, 44 이분검색 응용
//51 다이나믹
//56 재귀
//58 이진트리 깊이우선탐색
//65 STL vector 생성방법
//66 DFS 인접리스트 (벡터활용) 즘
//67 DFS 인접행렬
//68 DFS 가중치 방향그래프 인접리스트
//69 BFS 이진트리 넓이 우선탐색
//70 BFS 그래프 최단거리
//71 BFS 상태트리 검색
//72 최대 Heap 구조와 유사하게 운영이되는  Priority_queue
//75 최대 수입 스케쥴
//75  구조체를 이용한 STL vector 활용
//76 이항계수 메모리제이션
//77 disjoint-set
//78 크루스칼 알고리즘 트리의 최소비용 최소 스패닝트리에 대하여
//79 Prim MST 알고리즘 최소스패닝 트리, 정점 기준으로 추가해나간다. 반복해볼것

```
