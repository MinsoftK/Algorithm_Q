# 69. 이진트리 넓이우선탐색(BFS)

* 아래 그림과 같은 이진트리를 넓이우선탐색해 보세요. 간선 정보 6개를 입력받아 처리해보세요.

![](https://github.com/MinsoftK/c-Algorithm_Q/blob/master/img/69.png?raw=true)

넓이 우선 탐색 : 1 2 3 4 5 6 7



<br/>



#### ▣ 입력예제 1
1 2
1 3
2 4
2 5
3 6
3 7





#### ▣ 출력예제 1
1 2 3 4 5 6 7 

<br/>
<br/>


## 내가 짠 코드
*

<br/>

```c++


```


<br><br> 

## 풀이
* level기준으로 탐색한다.
Queue stack과 달리 먼저들어간게 먼저 나온다.
1번과 제일 가까운 순서로 최단거리로 방문하고 있다.

<br/>

```c++
#include <stdio.h>
#include <vector>
#include <algorithm>

using namespace std;

int Q[100], front = -1, back = -1, ch[10];
vector<int> map[10];
int main()
{
	freopen("input.txt", "rt", stdin);
	int i, a, b, x;
	for (i = 1; i <= 6; i++)
	{
		scanf("%d %d", &a, &b);		
		map[a].push_back(b);
		map[b].push_back(a);
	}
	Q[++back] = 1;
	ch[1] = 1;
	while (front < back)
	{
		x = Q[++front];
		printf("%d ", x);
		for (i = 0; i < map[x].size(); i++)
		{
			if (ch[map[x][i]] == 0)
			{
				ch[map[x][i]] = 1;
				Q[++back] = map[x][i];
			}
		} 
	}
}



//69
/*
************ pair 부분 출력파트   ***********
 	for (i = 1; i <= m; i++)
	{
		for(j = 0; j < map[i].size(); j++)
		{
			printf("map[%d][%d] : %d \n", i, map[i][j].first, map[i][j].second);
		}
	}

*********************************************
*/


//36 삽입정렬 
//43, 44 이분검색 응용 
//51 다이나믹 
//56 재귀
//58 이진트리 깊이우선탐색 
//65 STL vector 생성방법 
//66 DFS 인접리스트 (벡터활용) 
//67 DFS 인접행렬 
//68 DFS 가중치 방향그래프 인접리스트 
//69 BFS 이진트리 넓이 우선탐색 
```
