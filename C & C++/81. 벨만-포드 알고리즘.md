# 81. 벨만-포드 알고리즘

- N개의 도시가 주어지고, 각 도시들을 연결하는 도로와 해당 도로를 통행하는 비용이 주어질 때 한 도시에서 다른 도시로 이동하는데 쓰이는 비용의 최소값을 구하는 프로그램을 작성하세요.

![](https://github.com/MinsoftK/c-Algorithm_Q/blob/master/img/81.png?raw=true)

<br/>
<br/>

#### ▣ 입력설명

- 첫 번째 줄에는 도시의 수N(N<=100)과 도로수 M(M<=200)가 주어지고, M줄에 걸쳐 도로정보와 비용이 주어진다. 만약 1번 도시와 2번도시가 연결되고 그 비용이 13이면 “1 2 13”으로 주어진다. 그 다음 마지막 줄에 출발도시와 도착도시가 주어진다.

#### ▣ 출력설명

- 출발도시에서 도착도시까지 가는데 걸리는 최소비용과 경로를 출력한다. 음의 사이클이 존재할 경우 -1를 출력한다.

참고 : 벨만포드 알고리즘은 그래프가 음의 사이클이 존재하면 안된다.

#### ▣ 입력예제 1

5 7
1 2 5
1 3 4
2 3 -3
2 5 13
3 4 5
4 2 3
4 5 7
1 5

#### ▣ 출력예제 1

14

<br/>
<br/>

## 내가 짠 코드

-

<br/>

```c++

```

<br><br>

## 풀이

- 최소스패닝트리를 공부하면서 Union & find 활용과 다익스트라, 벨만-포드 알고리즘을 공부하면서 어쩔때 적용을 해야하는지는 아직 감이 오지 않는다. 생각보다 이해하기가 어려운 부분인 것 같다. 일단 흐름도보다는 코드를 보면서 이해하고 문제를 풀어나가면서 익숙해지기로 하자. 생각보다 이해가 어려운 부분들인 것 같다...

<br/>

```c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;

int dist[101];

struct Edge{
	int s;
	int e;
	int cost;

	Edge(int a, int b, int c)
	{
		s = a;
		e = b;
		cost = c;
	}
};

int main()
{
//	freopen("input.txt", "rt", stdin);
	int n,m,cost,i, j;
	int a, b, c;
	int start, end;
	vector<Edge> map;
	scanf("%d %d", &n, &m);
	for (i = 1; i <= m; i++)
	{
		scanf("%d %d %d", &a, &b, &c);
		map.push_back(Edge(a, b, c));
	}
	for (i = 1; i <= n; i++)
	{
		dist[i] = 2147000000;
	}
	scanf("%d %d", &start, &end);
	dist[start] = 0;
	for(i = 1; i < n; i++) //i가 1이땐 간선을 한번만 i가 3이면 간선이 3개인 경우
	{
		for (j = 0; j < map.size(); j++) //각각의 정점.
		{
			int u = map[j].s;
			int v = map[j].e;
			int w = map[j].cost;
			if (dist[u] != 2147000000 && dist[u] + w < dist[v])
			{
				dist[v] = dist[u] + w;
			}
		}
	}
	for (j = 0; j < map.size(); j++)
	{
		//간선의 개수가 n개일 때의 경우다.
		//간선을 n개 택해서 최소비용이 되는 경로가 있다면
		//음의 사이클이 존재한다는 의미이다.
		int u = map[j].s;
		int v = map[j].e;
		int w = map[j].cost;
		if (dist[u] != 2147000000 && dist[u] + w < dist[v])
		{
			printf("-1\n");
			exit(0);
		}
	}
	printf("%d\n", dist[end]);
	return (0);
}



//69
/*
************ pair 부분 출력파트   ***********
 	for (i = 1; i <= m; i++)
	{
		for(j = 0; j < map[i].size(); j++)
		{
			printf("map[%d][%d] : %d \n", i, map[i][j].first, map[i][j].second);
		}
	}

*********************************************
*/

//36 삽입정렬
//43, 44 이분검색 응용
//51 다이나믹
//56 재귀
//58 이진트리 깊이우선탐색
//65 STL vector 생성방법
//66 DFS 인접리스트 (벡터활용) 즘
//67 DFS 인접행렬
//68 DFS 가중치 방향그래프 인접리스트 즘
//69 BFS 이진트리 넓이 우선탐색
//70 BFS 그래프 최단거리
//71 BFS 상태트리 검색
//72 최대 Heap 구조와 유사하게 운영이되는  Priority_queue
//75 최대 수입 스케쥴
//75  구조체를 이용한 STL vector 활용
//76 이항계수 메모리제이션
//77 disjoint-set
//78 크루스칼 알고리즘 트리의 최소비용 최소 스패닝트리에 대하여
//79 Prim MST 알고리즘 최소스패닝 트리, 정점 기준으로 추가해나간다. 반복해볼것
//80 다익스트라 알고리즘
//81 벨만-포드 알고리
```
