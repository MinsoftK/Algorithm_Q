# 83. 복면산(SEND+MORE=MONEY(MS인터뷰)

- SEND+MORE=MONEY 라는 유명한 복면산이 있습니다. 이 복면산을 구하는 프로그램을 작성하세요.

<br/>
<br/>

#### ▣ 출력형태

<br/>

![](https://github.com/MinsoftK/c-Algorithm_Q/blob/master/img/83.png?raw=true)

<br/>
<br/>

## 내가 짠 코드

-

<br/>

```c++


```

<br><br>

## 풀이

-

<br/>

```c++
#include <stdio.h>
using namespace std;

int a[7], ch[7]; //ch는 check배열이고, a에는 d e m n o r s y 순으로 0 1 2 3 4 5 6 7 배열에 저장됐다 생각하자.

int send()
{
	return (a[6]*1000 + a[1] * 100 + a[3] *10 + a[0]);
}

int money()
{
	return (a[2] * 10000 + a[4] * 1000 + a[3] * 100 + a[1] * 10 + a[7]);
}

int more()
{
	return (a[2] * 1000 + a[4] * 100 + a[5] * 10 + a[1]);
}

void DFS(int L)
{
	if (L == 8)
	{
		if (send()+more() == money())
		{
			if (a[2] == 0 || a[6] == 0) return; //send와 more의 첫자리가 0인 경우는 return해준다.
			printf("  %d %d %d %d\n", a[6], a[1], a[3], a[0]);
			printf("+ %d %d %d %d\n", a[2], a[4], a[5], a[1]);
			printf("----------------\n");
			printf(" %d %d %d %d %d \n", a[2], a[4], a[3], a[1], a[7]);
		}
	}
	else
	{
		for (int i = 0; i < 10; i++)
		{
			if (ch[i] == 0)
			{
				a[L] = i;
				ch[i] = 1;
				DFS(L+1);
				ch[i] = 0;
			}
		}
	}
}

int main()
{
	DFS(0);
	return (0);
}



/*
************ pair 부분 출력파트   ***********
 	for (i = 1; i <= m; i++)
	{
		for(j = 0; j < map[i].size(); j++)
		{
			printf("map[%d][%d] : %d \n", i, map[i][j].first, map[i][j].second);
		}
	}

*********************************************
*/

//36 삽입정렬
//43, 44 이분검색 응용
//51 다이나믹
//56 재귀
//58 이진트리 깊이우선탐색
//65 STL vector 생성방법
//66 DFS 인접리스트 (벡터활용) 즘
//67 DFS 인접행렬
//68 DFS 가중치 방향그래프 인접리스트 즘
//69 BFS 이진트리 넓이 우선탐색
//70 BFS 그래프 최단거리
//71 BFS 상태트리 검색
//72 최대 Heap 구조와 유사하게 운영이되는  Priority_queue
//75 최대 수입 스케쥴
//75  구조체를 이용한 STL vector 활용
//76 이항계수 메모리제이션
//77 disjoint-set
//78 크루스칼 알고리즘 트리의 최소비용 최소 스패닝트리에 대하여
//79 Prim MST 알고리즘 최소스패닝 트리, 정점 기준으로 추가해나간다. 반복해볼것
//80 다익스트라 알고리즘
//81 벨만-포드 알고리즘
//82 순열구하기 (DFS : Depth First Search)
//83 복면산
```
