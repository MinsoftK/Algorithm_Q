# 65. 미로탐색(DFS)

-   자연수 N이 주어지면 7\*7 격자판 미로를 탈출하는 경로의 가지수를 출력하는 프로그램을 작
    성하세요. 출발점은 격자의 (1, 1) 좌표이고, 탈출 도착점은 (7, 7)좌표이다. 격자판의 1은 벽
    이고, 0은 통로이다. 격자판의 움직임은 상하좌우로만 움직인다. 미로가 다음과 같다면

![](https://github.com/MinsoftK/c-Algorithm_Q/blob/master/img/65.png?raw=true)

위의 지도에서 출발점에서 도착점까지 갈 수 있는 방법의 수는 8가지이다.

<br/>

#### ▣ 입력설명

-   첫 번째 줄에 자연수 N(1<=N<=20)이 주어집니다.
    두 번째 줄부터 격자판 정보가 주어진다.

#### ▣ 출력설명

-   첫 번째 줄에 경로의 가지수를 출력한다.

#### ▣ 입력예제 1

0 0 0 0 0 0 0
0 1 1 1 1 1 0
0 0 0 1 0 0 0
1 1 0 1 0 1 1
1 1 0 0 0 0 1
1 1 0 1 1 0 0
1 0 0 0 0 0 0

#### ▣ 출력예제 1

8

<br/>
<br/>

## 내가 짠 코드

-

<br/>

```c++


```

<br><br>

## 풀이

-

<br/>

```c++
#include <stdio.h>
#include <vector>
#include <algorithm>
#include <stack>
using namespace std;

int map[21][21], cnt, ch[21][21];
int n;
int dx[4] = {-1, 0, 1, 0}; // 12시 방향 기준 idx
int dy[4] = {0, 1, 0 , -1};
void DFS(int x, int y)
{
	int xx, yy;
	if(x == 7 && y == 7)
	{
		cnt++;
	}
	else
	{
		for (int i = 0; i <= 3; i++)
		{
			xx = x + dx[i]; //만약 이렇게 안하면 코드가 굉장히 길어진다.
			yy = y + dy[i];
			if (xx < 1 || xx > 7 || yy < 1 || yy > 7) continue; //범위를 벗어나면 다른 경로를 탐색하게 한다.
			if (map[xx][yy] == 0 && ch[xx][yy] == 0)
			{
				ch[xx][yy] = 1;
				DFS(xx, yy);
				ch[xx][yy] = 0;
			}
		}
	}
}

int main()
{
//	freopen("input.txt", "rt", stdin);
	int i, j;
	for(i = 1; i <= 7; i++)
	{
		for (j = 1; j <= 7; j++)
		{
			scanf("%d", &map[i][j]);
		}
	}
	ch[1][1] = 1;
	DFS(1,1);
	printf("%d", cnt);
	return(0);
}

//36 삽입정렬
//43, 44 이분검색 응용
//51 다이나믹
//56 재귀
//58 이진트리 깊이우선탐색
//64 경로탐색
//65 미로탐색

```

```java
class Solution {
    int[][] visit; // 방문 체크 배열
    ArrayList<Integer> list; // 영역별 넓이 저장
    int cnt, max; // 탐색하고 있는 영역의 넓이, 전체 영역 넓이 중 최대값
    int[] dotX={0,1,0,-1};
    int[] dotY={1,0,-1,0};
    public int[] solution(int m, int n, int[][] picture) {
        int[] answer = new int[2];

        visit=new int[m][n];
        list=new ArrayList<>();
        max=0;

        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                // 색깔이 있고 방문하지 않는 곳이면 해당 영역 찾기
                if(picture[i][j]!=0 && visit[i][j]==0){
                    cnt=1;
                    dfs(i, j, m, n, picture);
                    // 영역 탐색 완료 후 max, list에 값 저장
                    max=Math.max(max, cnt);
                    list.add(cnt);
                }
            }
        }

        answer[0] = list.size();
        answer[1] = max;
        return answer;
    }

    public void dfs(int x, int y, int m, int n, int[][] picture){
        visit[x][y]=picture[x][y]; // 방문했음을 표시

        for(int i=0;i<4;i++){ // 사방으로 갈 수 있는 좌표 계산
            int xx=x+dotX[i];
            int yy=y+dotY[i];
            if(xx<0 || xx>=m || yy<0 || yy>=n) continue; // 범위 초과
            if(visit[xx][yy]!=0) continue; // 방문한 곳이면 패스
            if(picture[xx][yy]==picture[x][y]){ // 현재 탐색 영역과 색깔이 같다면
                cnt++;
                dfs(xx, yy, m, n, picture); // 이동
            }
        }
    }
}
```
