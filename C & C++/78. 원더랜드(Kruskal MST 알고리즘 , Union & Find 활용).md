# 78. 원더랜드(Kruskal MST 알고리즘 , Union & Find 활용)

- 원더랜드에 문제가 생겼다. 원더랜드의 각 도로를 유지보수하는 재정이 바닥난 것이다.
  원더랜드는 모든 도시를 서로 연결하면서 최소의 유지비용이 들도록 도로를 선택하고 나머지 도로는 폐쇄하려고 한다.
  아래의 그림은 그 한 예를 설명하는 그림이다.

![](https://github.com/MinsoftK/c-Algorithm_Q/blob/master/img/78.png?raw=true)

위의 지도는 각 도시가 1부터 9로 표현되었고, 지도의 오른쪽은 최소비용 196으로 모든 도시를 연결하는 방법을 찾아낸 것이다.

<br/>
<br/>

#### ▣ 입력설명

- 첫째 줄에 도시의 개수 V(1≤V≤100)와 도로의 개수 E(1≤E≤1,000)가 주어진다. 다음 E개의 줄에는 각 도로에 대한 정보를 나타내는 세 정수 A, B, C가 주어진다. 이는 A번 도시와 B번 도시가 유지비용이 C인 도로로 연결되어 있다는 의미이다. C는 1,000,000을 넘지 않는 자연수이다.

#### ▣ 출력설명

- 모든 도시를 연결하면서 드는 최소비용을 출려한다.

#### ▣ 입력예제 1

9 12  
1 2 12  
1 9 25  
2 3 10  
2 8 17  
2 9 8  
3 4 18  
3 7 55  
4 5 44  
5 6 60  
5 7 38  
7 8 35  
8 9 15

#### ▣ 출력예제 1

196

<br/>
<br/>

## 내가 짠 코드

-

<br/>

```c++


```

<br><br>

## 풀이

- 77번과 많이 헷갈렸다. find하고 union의 과정을 잘 이해해야 한다.

<br/>

```c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <algorithm>
using namespace std;
int unf[10001];

struct s_city{
	int v1;
	int v2;
	int cost;
	s_city(int a, int b, int c)
	{
		v1 = a;
		v2 = b;
		cost = c;
	}
	bool operator<(s_city &b)
	{
		return (cost < b.cost);
	}
};

int find(int v)
{
	if (v == unf[v]) return v;
	else return unf[v] = find(unf[v]);
}

void Union(int a, int b)
{
	a = find(a);
	b = find(b);
	if (a != b) unf[a] = b;
}

int main()
{
	freopen("input.txt", "rt", stdin);
	int v, e, a, b, c, i;
	int res = 0; //비용 더하는 변수
	vector<s_city> temp;
	scanf("%d %d", &v, &e);
	for(i = 1; i <= v; i++)
		unf[i]= i;
	for (i = 1; i <= e; i++)
	{
		scanf("%d %d %d", &a, &b, &c);
		temp.push_back(s_city(a,b,c)); //city 구조체의 abc값을 넣고 temp 벡터에 push
	}
	sort(temp.begin(), temp.end());
	for (i = 0; i < e; i++) //벡터에 들어갔기 때문에 0으로 시작한다.
	{
		int fa = find(temp[i].v1);
		int fb = find(temp[i].v2);
		if (fa != fb)
		{
			res += temp[i].cost;
			Union(temp[i].v1, temp[i].v2);
		}
	}
	//이 부분이 77번과 많이 헷갈린다. 77번에서는 그냥 노드끼리의 입력을 해주면 됐다.
	//하지만 이 부분에서는 이미 연결이 됐을 경우는 제외해야하기 때문에
	//find 과정이 한번더 진행된다. 그러면 경로 최적화가 된 부모노드를 기준으로 트리가 형성
	printf("%d\n", res);
	return (0);
}



//69
/*
************ pair 부분 출력파트   ***********
 	for (i = 1; i <= m; i++)
	{
		for(j = 0; j < map[i].size(); j++)
		{
			printf("map[%d][%d] : %d \n", i, map[i][j].first, map[i][j].second);
		}
	}

*********************************************
*/

//36 삽입정렬
//43, 44 이분검색 응용
//51 다이나믹
//56 재귀
//58 이진트리 깊이우선탐색
//65 STL vector 생성방법
//66 DFS 인접리스트 (벡터활용)
//67 DFS 인접행렬
//68 DFS 가중치 방향그래프 인접리스트
//69 BFS 이진트리 넓이 우선탐색
//70 BFS 그래프 최단거리
//71 BFS 상태트리 검색
//72 최대 Heap 구조와 유사하게 운영이되는  Priority_queue
//75 최대 수입 스케쥴
//75  구조체를 이용한 STL vector 활용
//76 이항계수 메모리제이션
//77 disjoint-set
//78 크루스칼 알고리즘 트리의 최소비용 (최소 스패닝트리)
```
