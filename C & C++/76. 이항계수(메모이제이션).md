# 76. 이항계수(메모이제이션)

* 현수는 유명한 강연자이다. N개이 기업에서 강연 요청을 해왔다. 각 기업은 D일 안에 와서 강연을 해 주면 M만큼의 강연료를 주기로 했다.
각 기업이 요청한 D와 M를 바탕으로 가장 많을 돈을 벌 수 있도록 강연 스케쥴을 짜야 한다. 
단 강연의 특성상 현수는 하루에 하나의 기업에서만 강연을 할 수 있다.



<br/>
<br/>

#### ▣ 입력설명

* 첫 번째 줄에 자연수 N(1<=N<=10,000)이 주어지고, 다음 N개의 줄에 M(1<=M<=10,000)과 D(1<=D<=10,000)가 차례로 주어진다.


#### ▣ 출력설명

* 첫 번째 줄에 최대로 벌 수 있는 수입을 출력한다.




#### ▣ 입력예제 1
6
50 2
20 1
40 2
60 3
30 3
30 1





#### ▣ 출력예제 1
150

<br/>
<br/>


## 내가 짠 코드
*

<br/>

```c++


```


<br><br> 

## 풀이
* 

<br/>

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;
int mem[21][21]; 
int	DFS(int n, int r)
{
	if (mem[n][r] > 0) //mem의 배열에 값이 0보다 크다면 값이 존재하므로 그 값을 return해준다. 
		return mem[n][r]; 
	if (r == 0 || n == r)
		return (1);
	else
		return mem[n][r] = (DFS(n-1 , r-1) + DFS(n-1, r)); //메모리제이션 
}

int main()
{
	freopen("input.txt", "rt", stdin);	
	int n, r;
	scanf("%d %d", &n, &r);	
	printf("%d", DFS(n, r));
}

//69
/*
************ pair 부분 출력파트   ***********
 	for (i = 1; i <= m; i++)
	{
		for(j = 0; j < map[i].size(); j++)
		{
			printf("map[%d][%d] : %d \n", i, map[i][j].first, map[i][j].second);
		}
	}

*********************************************
*/

//36 삽입정렬 
//43, 44 이분검색 응용 
//51 다이나믹 
//56 재귀
//58 이진트리 깊이우선탐색 
//65 STL vector 생성방법 
//66 DFS 인접리스트 (벡터활용) 
//67 DFS 인접행렬 
//68 DFS 가중치 방향그래프 인접리스트 
//69 BFS 이진트리 넓이 우선탐색 
//70 BFS 그래프 최단거리 
//71 BFS 상태트리 검색 
//72 최대 Heap 구조와 유사하게 운영이되는  Priority_queue
//75 최대 수입 스케쥴
//76 이항계수 메모리제이션  
```
