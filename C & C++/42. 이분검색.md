# 42. 이분검색

* 임의의 N개의 숫자가 입력으로 주어집니다. N개의 수를 오름차순으로 정렬한 다음 N개의 수 
중 한 개의 수인 M이 주어지면 이분검색으로 M이 정렬된 상태에서 몇 번째에 있는지 구하는 
프로그램을 작성하세요.




#### ▣ 입력설명

* 첫 줄에 한 줄에 자연수 N(3<=N<=1,000,000)과 M이 주어집니다.
두 번째 줄에 N개의 수가 공백을 사이에 두고 주어집니다.







#### ▣ 출력설명

* 첫 줄에 정렬 후 M의 값의 위치 번호를 출력한다.








#### ▣ 입력예제 1
8 32
23 87 65 12 57 32 99 81








#### ▣ 출력예제 1
3




## 내가 짠 코드
* 탐색을 하고 나서도 mid값이 계속 바뀌어야 되는 것을 놓쳤다.
```c++
#include <stdio.h>
#include <vector>
#include <algorithm>
using namespace std;
int main()
{
//	freopen("input.txt","rt",stdin);
	int num, key, i, lt, rt, mid;
	scanf("%d %d", &num, &key);
	vector<int> arr(num);
	for (i = 0; i < num; i++)
		scanf("%d", &arr[i]);
	// scanf("%d", tmp);
	//arr.push_back(tmp);  이렇게로도 가능하다. 
	sort(arr.begin(),arr.end());
	lt = 0;
	rt = num - 1;
	mid = (lt + rt) / 2;
	if (arr[mid] == key)
		printf("%d", mid + 1);
	else if (arr[mid] < key)
	{
		for (i = mid; i < rt; i++)
		{
			if (arr[i] == key)
			{
				printf("%d", i + 1);
				break;
			}
		}
	}
	else if (arr[mid] > key)
	{
		for (i = lt; i < mid; i++)
		{
			if (arr[i] == key)
			{
				printf("%d", i + 1);
				break;
			}
		}
	}
	return (0);
}

```
* 일차원 배열에 정렬한 상태에서 검색하는 방법.left변수와 right 변수가 필요. 정확하게 절반 지점을 찾아간다. mid라는 변수가 필요하다. mid = (lt + rt) / 2; 로 선언할 수 있다. 
만약에 a라는 배열의 a[mid]값이 key와 같은가? 같다면 mid+1 값을 반환
만약 a[mid] > key라면 left쪽을 탐색하면 된다. 반대로 a[mid] < key라면 오른쪽을 탐색해주면 된다.
a.push_back(tmp); 로도 할용할 수 있다.
자료를 맨 뒤에서 삽입하고 삭제한다.

<br><br> 

## 풀이
* 굉장히 간단하게 while을 활용해서 끝냈다. 만약에 for문을 썼다면 굉장히 복잡해졌을 것이다. 내가 작성했던 것처럼 굉장히 복잡하다.
<br/>
```c++
#include <stdio.h>
#include <vector>
#include <algorithm>
using namespace std;
int main()
{
//	freopen("input.txt","rt",stdin);
	int num, key, i, lt, rt, mid;
	scanf("%d %d", &num, &key);
	vector<int> arr(num);
	for (i = 0; i < num; i++)
		scanf("%d", &arr[i]);
	// scanf("%d", tmp);
	//arr.push_back(tmp);  이렇게로도 가능하다. 
	sort(arr.begin(),arr.end());
	lt = 0;
	rt = num - 1;
	while (lt <= rt)
	{
		mid = (lt + rt) / 2;
		if (arr[mid] == key)
		{
			printf("%d", mid + 1);
			return 0;	
		}
		else if (arr[mid] < key)
			lt = mid + 1;
		else if (arr[mid] > key)
			rt = mid - 1;
	}
	return (0);
}
}
```
