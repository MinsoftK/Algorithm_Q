function solution(cards) {
	var answer = 0;
	let hash = new Map();
	let check = Array(cards.length).fill(0);
	cards.forEach((card, i) => {
		hash.set(i + 1, card);
	});

	// 순차로 교환
	for (let i = 1; i <= cards.length - 1; i++) {
		for (let j = i + 1; j <= cards.length; j++) {
			if (check[i] === 1 || check[j] === 1) continue;
			let [a_idx, a_min] = minIndex(hash.get(i));
			let [b_idx, b_min] = minIndex(hash.get(j));
			if (a_min === 0 || b_min === 0) continue;
			if (a_idx !== b_idx) {
				// console.log(hash);
				let temp_a = hash.get(i);
				let temp_b = hash.get(j);
				let flag = false;
				for (let i = 0; i < temp_a; i++){
					if (temp_a[i] < temp_b[i]) 
				}
				// console.log(temp_a, temp_b);
				// a카드에서 가장 작은 값 카드
				temp_a[a_idx] += 1;
				temp_b[a_idx] -= 1;

				temp_b[b_idx] += 1;
				temp_a[b_idx] -= 1;
				// console.log(temp_a, temp_b, a_min, b_min);
				if (Math.min(...temp_a) <= a_min || Math.min(...temp_b) <= b_min) {
					break;
				}
				// console.log(i, j, temp_a, temp_b, a_min, b_min);
				check[i] = 1;
				check[j] = 1;
				hash.set(i, temp_a);
				hash.set(j, temp_b);
			}
		}
	}
	console.log(hash);

	for (let [key, val] of hash) {
		answer += Math.min(...val);
	}
	return answer;
}

function minIndex(arr) {
	let min = 1e9;
	let idx = 0;
	for (let i = 0; i < arr.length; i++) {
		if (arr[i] < min) {
			min = arr[i];
			idx = i;
		}
	}
	return [idx, min];
}

console.log(
	solution([
		[10, 5, 15],
		[5, 15, 10],
		[10, 11, 9],
	])
);

console.log(
	solution([
		[10, 5, 15],
		[8, 9, 13],
		[10, 10, 10],
	])
);

console.log(
	solution([
		[0, 0, 30],
		[30, 0, 0],
	])
);
console.log(
	solution([
		[8, 11, 11],
		[6, 15, 9],
		[14, 2, 14],
		[8, 20, 2],
	])
);
console.log(
	solution([
		[8, 11, 11],
		[10, 7, 13],
		[15, 10, 5],
		[7, 17, 6],
	])
);

// 1번부터 순서대로 번호가 매겨진 사람들이 카드를 각각 30장씩 갖고 있습니다. 카드는 빨간색(R), 초록색(G), 파란색(B) 3종류이며, 가장 적게 갖고 있는 카드 매수로 점수가 결정됩니다. 예를 들어 빨간 카드 10장, 초록 카드 5장, 파란 카드 15장으로 구성된 카드 뭉치를 갖고 있다면 5점을 받습니다.
// 모든 사람은 한 번씩, 다른 사람과 카드를 1장 교환할 수 있는 기회를 가집니다. 원하지 않는다면 기회를 쓰지 않을 수도 있습니다. 만약 다른 사람의 교환 신청을 받아들여 교환을 했다면 교환 기회를 사용한 것으로 간주합니다. 모든 교환이 끝난 뒤, 사람들의 카드 점수 합을 구하려고 합니다.
// 사람들은 다음과 같은 규칙에 따라 교환 상대를 결정합니다.

// • 1번 사람부터 차례대로 교환 상대를 지목합니다.
// • 교환을 통해 양쪽이 동시에 이득을 볼 수 있어야 합니다. 즉, 각자의 점수(=가장 적게 갖고 있는 카드 매수)가 동시에 상승해야 합니다.
// • 교환 가능한 사람이 여러 명일 경우, 가장 번호가 낮은 사람과 교환합니다.

// 아래 표는 세 사람의 카드 매수를 나타내는 예시입니다.

// 번호	R	G	B
// 1번	10	5	15
// 2번	5	15	10
// 3번	10	11	9
// 1번부터 차례대로 교환 상대를 지목합니다. 1번은 2번 또는 3번과 카드를 교환할 수 있습니다. 그 중에서 가장 번호가 낮은 2번과 교환합니다. 1번은 R을, 2번은 G를 상대방에게 건네줍니다. 그러면 다음과 같이 카드 매수가 변합니다.

// 번호	R	G	B
// 1번	9	6	15
// 2번	6	14	10
// 3번	10	11	9
// 2번은 이미 1번과 교환했기 때문에 더 이상 교환을 할 수가 없습니다. 3번은 교환할 상대가 남아있지 않기 때문에 교환을 할 수가 없습니다. 따라서 모든 교환이 끝난 뒤, 세 사람의 점수 합은 21점(=6+6+9)입니다.
// 1번 사람부터 차례대로 종류별 카드 매수를 담은 2차원 정수 배열 cards가 매개변수로 주어집니다. 각자 한 번씩 교환할 수 있는 기회가 주어졌을 때, 모든 교환이 끝난 후 점수 합계를 return 하도록 solution 함수를 완성해주세요.
// ※ 주의 : 점수의 합을 최대화하는 것이 아니라, 주어진 규칙대로 교환을 수행해야 합니다.

// • 1 ≤ cards 의 길이(=사람의 수) ≤ 100
// ◦ cards 원소의 길이 = 3
// ◦ cards 원소는 [R, G, B] 형태입니다.
// ◦ R, G, B는 각각 빨간색, 초록색, 파란색 카드의 매수를 나타냅니다.
// ◦ 0 ≤ R, G, B ≤ 30
// ◦ R+G+B = 30

// 입출력 예

// cards	result
// [[10, 5, 15], [5, 15, 10], [10, 11, 9]]	21
// [[10, 5, 15], [8, 9, 13], [10, 10, 10]]	23
// [[8, 11, 11], [6, 15, 9], [14, 2, 14], [8, 20, 2]]	22
// [[8, 11, 11], [10, 7, 13], [15, 10, 5], [7, 17, 6]]	28
// [[0, 0, 30], [30, 0, 0]]	0
// 입출력 예#1
// 문제 예시와 같습니다.

// 입출력 예#2
// 세 사람은 모두 교환을 하지 않습니다. 이유는 아래와 같습니다. • 1번과 2번 : 1번은 G를 얻기 위해 R과 B를 내어줄 수 있습니다. 2번은 R을 필요로 하지만
// G를 내어줄 경우, G가 8장이 되기 때문에 점수에 이득이 없습니다. 따라서 교환을 하지 않습니다.
// • 1번과 3번 : 점수를 최대화할 수 있는 카드 조합을 이미 갖고 있는 3번은 교환을 통해 이득을 볼 수 없기 때문에 교환을 원하지 않습니다.
// • 2번과 3번 : 위와 같은 이유로 3번은 교환을 원하지 않습니다.
// 따라서 5+8+10=23을 return 합니다.

// 입출력 예#3
// 초기 카드 구성은 아래 표와 같습니다. 다음과 같은 과정을 거쳐 교환이 이루어집니다.

// 번호	R	G	B
// 1번	8	11	11
// 2번	6	15	9
// 3번	14	2	14
// 4번	8	20	2
// • 1번과 2번 : 두 사람 모두 원하는 카드가 R이기 때문에 교환을 하지 않습니다.
// • 1번과 3번 : 1번은 G를 내어주고, 3번은 R을 내어주면 서로 이득이므로 교환합니다. 1번은[9, 10, 11], 3번은 [13, 2, 14]가 됩니다.
// • 2번과 3번 : 3번이 이미 1번과 교환했습니다.
// • 2번과 4번 : 2번은 B를 내어주고, 4번은 R을 내어주면 서로 이득이므로 교환합니다. 2번은[7, 15, 8], 4번은 [7, 20, 3]이 됩니다.
// 교환이 모두 끝난 후 네 사람의 점수 합은 22(=9+7+3+3)입니다. 따라서 22를 return 합니다.

// 입출력 예#4
// 초기 카드 구성은 아래 표와 같습니다. 다음과 같은 과정을 거쳐 교환이 이루어집니다.

// 번호	R	G	B
// 1번	8	11	11
// 2번	10	7	13
// 3번	15	10	5
// 4번	7	17	6
// • 1번과 2번 : 1번은 G를 내어주고, 2번은 R을 내어주면 서로 이득이므로 교환합니다. 1번은[9, 10, 11], 2번은 [9, 8, 13]이 됩니다.
// • 3번과 4번 : 두 사람 모두 원하는 카드가 B이기 때문에 교환을 하지 않습니다.
// 교환이 모두 끝난 후 네 사람의 점수의 합은 28(=9+8+5+6)입니다. 따라서 28을 return 합니다.
// 만약 1번과 3번이 서로 교환하고, 2번과 4번이 서로 교환했다면 네 사람의 점수의 합을 30으로 최대화할 수 있습니다. 하지만 규칙에 따라 교환하기 때문에 30은 정답이 될 수 없습니다.

// 입출력 예#5
// 두 사람은 갖고 있는 카드를 서로 한 장씩 교환하더라도 점수가 0점으로 달라지지 않으며, 이득이 없으므로 교환을 하지 않습니다. 따라서 0+0=0을 return 합니다.
