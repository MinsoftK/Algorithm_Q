# 49. 블록의 최댓값

* 현수는 블록놀이를 좋아합니다. 현수에게 정면에서 본 단면과 오른쪽 측면에서 본 단면을 주고 최대 블록개수를 사용하여 정면과 오른쪽 측면에서 본 모습으로 블록을 쌓으라 했습니다. 현수가 블록을 쌓는데 사용해야 할 최대 개수를 출력하는 프로그램을 작성하세요.


![봉우리](https://github.com/MinsoftK/c-Algorithm_Q/blob/master/img/49.png?raw=true)
<br/>

위에서 봤을 때 각 칸의 블록의 개수입니다. 정면에서의 높이 정보와 오른쪽 측면에서의 높이 정보가 주어지면 사용할 수 있는 블록의 쵀대 개수를 출력하세요.


#### ▣ 입력설명

* 첫 줄에 블록의 크기 N(3<=N<=10)이 주어집니다. 블록이 크기는 정사각형 N*N입니다.
두 번째 줄에 N개의 정면에서의 높이 정보가 왼쪽 정보부터 주어집니다.
세 번째 줄에 N개의 오른쪽 측면 높이 정보가 앞쪽부터 주어집니다.
블록의 높이는 10 미만입니다.




#### ▣ 출력설명

* 첫 줄에 블록의 최대 개수를 출력합니다.






#### ▣ 입력예제 1
4
2 0 3 1
1 1 2 3




#### ▣ 출력예제 1
17


## 내가 짠 코드
* 만약에 정면 블록에서부터 시작해서 정면 블록의 값과 side에서의 블록값이 작다면 side의 블록값을 map에 입력한다. 반대로 side 값이 더 크다면 정면의 값을 넣어버린다. 정면의 값보다 더 커질 수는 없기 때문이다.

```c++
#include <stdio.h>
#include <vector>
#include <algorithm>
using namespace std;

int map[11][11];
int front[11];
int rtside[11];
int main()
{
//	freopen("input.txt","rt",stdin);
	int block, i, j, tmp, sum = 0;
	scanf("%d", &block);
	for (i = 1; i <= block; i++)
		scanf("%d", &front[i]);
	for (i = 1; i <= block; i++)
		scanf("%d", &rtside[i]);
	for (i = 1; i <= block; i++)
	{

		for (j = 1; j <= block; j++)
		{
			if (front[i] >= rtside[j])
			{
				map[i][j] = rtside[j];	
				sum += map[i][j];
			}
			else if (front[i] < rtside[j])
			{
				map[i][j] = front[i];
				sum += map[i][j];
			}
		}
	}
	printf("%d", sum);
	return (0);
}

```
* 최대 개수로 채우고 시작을 한다!
front, side 모두 최대값을 고려해서 map을 채우도록 한다!
<br><br> 

## 풀이
*  
<br/>
```c++


```
