# 40. 교집합(투포인트 알고리즘)

* 두 집합 A, B가 주어지면 두 집합의 교집합을 출력하는 프로그램을 작성하세요.




#### ▣ 입력설명

* 첫 번째 줄에 집합 A의 크기 N(1<=N<=30,000)이 주어집니다.
두 번째 줄에 N개의 원소가 주어집니다. 원소가 중복되어 주어지지 않습니다.
세 번째 줄에 집합 B의 크기 M(1<=M<=30,000)이 주어집니다.
네 번째 줄에 M개의 원소가 주어집니다. 원소가 중복되어 주어지지 않습니다.
각 집합의 원소는 int형 변수의 크기를 넘지 않습니다.





#### ▣ 출력설명

* 두 집합의 교집합을 오름차순 정렬하여 출력합니다.






#### ▣ 입력예제 1
5
2 7 10 5 3
5
3 10 5 17 12







#### ▣ 출력예제 1

3 5 10



## 내가 짠 코드
* 마지막 문제에서 time limit에 걸려버린다. 이중 while과 이중 for문을 사용해서 시간 초과에 계속 걸려버린다. 
```c++

#include <stdio.h>
#include <vector>
using namespace std;
int main()
{
//	freopen("input.txt","rt",stdin);
	int num1, num2, i, j, pos1 = 0, pos2 = 0, pos3 = 0, temp;
	scanf("%d", &num1);
	vector<int> arr1(num1);
	for (i = 0; i < num1; i++)
		scanf("%d", &arr1[i]);
	scanf("%d", &num2);
	vector<int> arr2(num2);
	for (i = 0; i < num2; i++)
		scanf("%d", &arr2[i]);
	vector<int> arr3(num1);
	while (pos1 < num1)
	{
		pos2 = 0;
		while (pos2 < num2)
		{
			if(arr1[pos1] == arr2[pos2])
			{	
				arr3[pos3] = arr2[pos2];
				pos3++;
			}	
			pos2++;		
		}
		pos1++;
	}
	for (i = 0; i < pos3; i++)
	{
		for (j = i + 1; j < pos3; j++)
		{
			if (arr3[i] > arr3[j])
			{
				temp = arr3[i];
				arr3[i] = arr3[j];
				arr3[j] = temp;
			}
		}
	}
	for (i = 0; i < pos3; i++)
		printf("%d ", arr3[i]);
	return (0);
}



```
* 
<br><br> 

## 풀이
* 먼저 정렬을 한 다음에 배열에 집어넣는다. 그러면 나중에 for문에서 탐색을 할 때 문제가 되지 않는다. 근데 정렬하기 위해선 이중 for문이 2번써야되는거 아닌가?라는 의문이 생김. 
sort를 활용한 빠른 정렬이 가능했다.
<br/>
```c++
#include <stdio.h>
#include <stdio.h>
#include <vector>
#include <algorithm> //sort를 제공하는 헤더 퀵소트로 빠르게 정렬한다.
					// 버블, 선택 같은 경우는 시간이 오래 걸린다. 
using namespace std;
int main()
{
//	freopen("input.txt","rt",stdin);
	int num1, num2, i, j, pos1 = 0, pos2 = 0, pos3 = 0, temp;
	scanf("%d", &num1);
	vector<int> arr1(num1);
	for (i = 0; i < num1; i++)
		scanf("%d", &arr1[i]);
	sort(arr1.begin(), arr1.end());
	scanf("%d", &num2);
	vector<int> arr2(num2);
	for (i = 0; i < num2; i++)
		scanf("%d", &arr2[i]);
	sort(arr2.begin(), arr2.end());
	vector<int> arr3(num1 + num2);

	while (pos1 < num1 && pos2 < num2)
	{
		if (arr1[pos1] < arr2[pos2])
			pos1++;
		if (arr1[pos1] > arr2[pos2])
			pos2++;
		if (arr1[pos1] == arr2[pos2])
		{
			arr3[pos3++] = arr2[pos2];
			pos1++;
			pos2++;
		}
	}
	for (i = 0; i < pos3; i++)
		printf("%d ", arr3[i]);
	return (0);
}
```
