# 48. 각 행의 평균과 가장 가까운 값
* <그림 1>과 같이 9 × 9 격자판에 쓰여진 81개의 자연수가 주어질 때, 각 행의 평균을 구하고, 그 평균과 가장 가까운 값을 출력하는 프로그램을 작성하세요. 평균은 소수점 첫 째 자리에서 반올림합니다. 평균과 가까운 값이 두 개이면 그 중 큰 값을 출력하세요.



#### ▣ 입력설명

* 첫 째 줄부터 아홉 번째 줄까지 한 줄에 아홉 개씩 자연수가 주어진다. 주어지는 자연수는 100보다 작다.




#### ▣ 출력설명

* 첫째 줄에 첫 번째 줄부터 각 줄에 각행의 평균과 그 행에서 평균과 가장 가까운 수를 출력한다.






#### ▣ 입력예제 1
3 23 85 34 17 74 25 52 65
10 7 39 42 88 52 14 72 63
87 42 18 78 53 45 18 84 53
34 28 64 85 12 16 75 36 55
21 77 45 35 28 75 90 76 1
25 87 65 15 28 11 37 28 74
65 27 75 41 7 89 78 64 39
47 47 70 45 23 65 3 41 44
87 13 82 38 50 12 48 29 80



#### ▣ 출력예제 1
42 34
43 42
53 53
45 36
50 45
41 37
54 64
43 44
49 50



## 내가 짠 코드
* 만약 정답이 2개일 때, 더 큰값을 출력 시켜줘야하는데 그 결과는 생각치 않았는데 우연히 정답으로 나왔다. 테스트 케이스를 생각 못한 것 같다. 

```c++
#include <stdio.h>
#include <vector>
#include <algorithm>
using namespace std;

int map[10][10];
int average[10];
int main()
{
//	freopen("input.txt","rt",stdin);
	int i, j ,tmp;
	float sum = 0 ,avg = 0, min;
	for (i = 1; i <= 9; i++)
	{
		for (j = 1; j <= 9; j++)
		{
			scanf("%d", &map[i][j]);
			sum += map[i][j];
		}
		average[i] = (sum / 9) + 0.5;
		//연산되는 두 연산이 자료형이 실수/ 정수여야 실수가 나온다.
		sum = 0;
	}
	for (i = 1; i <= 9; i++)
	{
		min = 100;
		for (j = 1; j <= 9; j++)
		{
			if (abs((average[i] - map[i][j])) < min)
			{
				min = abs((average[i] - map[i][j]));
				tmp = map[i][j];
			}
//				printf("tmp : %d\n map[i][j] = %d  ", tmp, map[i][j]);
		}
		printf("%d %d\n", average[i], tmp);
	}
	return (0);
}


```
* 
<br><br> 

## 풀이
* for문안에서 출력을 바로 처리하게 만들어서 2중 for문을 한번만 사용해서 프로그램을 완성 시켰다. 그리고 tmp와 min이 같을 경우와 tmp가 더 클 경우를 생각해주는 과정이 빠져버렸다. res와 tmp가 같을 경우를 생각을 못해줬다. 효율적인 코드가 가능했다.
<br/>

```c++

#include <stdio.h>
#include <vector>
#include <algorithm>
using namespace std;

int map[10][10];
int main()
{
	freopen("input.txt","rt",stdin);
	int i, j ,tmp;
	float sum = 0 ,avg = 0, min, res;
	for (i = 1; i <= 9; i++)
	{
		for (j = 1; j <= 9; j++)
		{
			scanf("%d", &map[i][j]);
			sum += map[i][j];
		}
		avg= (sum / 9.0) + 0.5;
		printf("%d ", avg);
		min = 1000;
		for (j = 1; j <= 9; j++)
		{
			tmp = abs(a[i][j] - avg);
			if (tmp < min)
			{
				min = tmp;
				res = a[i][j];
			}
			else if (tmp == min)
			{
				if (a[i][j] > res)	res = a[i][j];
			}
		}
		printf("%d\n", res);
	}
	return (0);
}

```
