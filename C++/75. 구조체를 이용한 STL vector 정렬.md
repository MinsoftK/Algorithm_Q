```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
struct Loc
{
	int x, y, z;
	//생성자
	Loc(int a, int b, int c)
	{
		x = a;
		y = b;
		z = c;	
	}
	bool operator<(const Loc &b)const{ //call by reference
	//구조체 b의 원본을 바꿀 수가 있다 방지하기 위해 const를 붙인다. 
	//함수 뒤에다가 const를 걸면 상수멤버함수가 된다.
	//operator라는 함수는 이제 멤버변수인 x, y, z를 변경할 수 없다. 
		//return (x < b.x); 오름차순 
		//return (x >= b.x); 내림차순일때 
		if (x != b.x) return x<b.x;
		if (y != b.y) return y<b.y;
		if (z != b.z) return z<b.z;
		//정확하게 이해한건지는 모르겠지만 sort에서 temp에 대한 객체가 들어가는데 
		//객체의 타입이 Loc 구조체이다. 따라서 sort에서 비교 연산을 할때
		//Loc 내부의 연산자 오버로딩에 따라서 연산이 된다.
		// 그러면 x와 b.x를 비교해서 true인지 false인지를 return 해준다. 
		//따라서 객체의 값들을 비교해서 sort에 전달해주므로 객체 매개인자에 따라
		//정렬될 수 있다. 
	}
	//연산자 오버로딩
	//https://ssungkang.tistory.com/entry/C-%EC%97%B0%EC%82%B0%EC%9E%90-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9Overloading  
};
int main()
{
	freopen("input.txt", "rt", stdin);
	vector<Loc> temp;
	temp.push_back(Loc(2,3,5));
	temp.push_back(Loc(3,6,7));
	temp.push_back(Loc(2,3,1));
	temp.push_back(Loc(5,2,3));
	temp.push_back(Loc(3,1,6));
	sort(temp.begin(), temp.end()); //include algorithm 
	for(auto pos : temp) 
		cout<<pos.x<<" "<< pos.y<<" " <<pos.z<<endl;
	//auto 어떤 타입도 대입 가능 map 배열의 모든 요소를 출력
	//배열에 대한 인덱스가 아니라 배열의 요소값이 pos에 할당된다. 
	return (0);
}



//69
/*
************ pair 부분 출력파트   ***********
 	for (i = 1; i <= m; i++)
	{
		for(j = 0; j < map[i].size(); j++)
		{
			printf("map[%d][%d] : %d \n", i, map[i][j].first, map[i][j].second);
		}
	}

*********************************************
*/


//36 삽입정렬 
//43, 44 이분검색 응용 
//51 다이나믹 
//56 재귀
//58 이진트리 깊이우선탐색 
//65 STL vector 생성방법 
//66 DFS 인접리스트 (벡터활용) 
//67 DFS 인접행렬 
//68 DFS 가중치 방향그래프 인접리스트 
//69 BFS 이진트리 넓이 우선탐색 
//70 BFS 그래프 최단거리 
//71 BFS 상태트리 검색 
//72 최대 Heap 구조와 유사하게 운영이되는  Priority_queue 
```
