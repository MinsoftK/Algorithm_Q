# 35. Special Sort(구글)

* N개의 정수가 입력되면 당신은 입력된 값을 정렬해야 한다. 음의 정수는 앞쪽에 양의정수는 뒷쪽에 있어야 한다. 또한 양의정수와 음의정수의 순서에는 변함이 없어야 한다.




#### ▣ 입력설명

* 첫 번째 줄에 정수 N(5<=N<=100)이 주어지고, 그 다음 줄부터 음수를 포함한 정수가 주어진다. 숫자 0은 입력되지 않는다. 




#### ▣ 출력설명

* 정렬된 결과를 출력한다.




#### ▣ 입력예제 1
8
1 2 3 -3 -2 5 6 -6






#### ▣ 출력예제 1

-3 -2 -6 1 2 3 5 6


## 내가 짠 코드

```c++
#include <stdio.h>
#include <limits.h>
int main()
{
	freopen("input.txt","rt",stdin);
	int num, i, j, k, res, count;
	int temp[100];
	int plus[100];
	int minus[100];
	scanf("%d", &num);
	
	i = 0;
	while (i < num)
	{
		scanf("%d", &temp[i]);
		i++;
	}

	j = 0;
	k = 0;
	for (i = 0; i < num; i++)
	{
		if (temp[i] > 0)
			plus[j++] = temp[i];
		
		if (temp[i] < 0)
			minus[k++] = temp[i];
	}
	for (i = 0; i < k; i++)
	{
		temp[i] = minus[i];
	}
	for (i = 0; i < j; i++)
	{
		temp[k + i] = plus[i];
	}
	for (i = 0; i < num; i++)
		printf("%d ", temp[i]);
	return (0);
}


```
* 정렬로 짜진 않고 약간 꼼수친 느낌이다. minus와 plus를 따로 저장하는 배열을 만든 뒤, temp에 합쳐줬다.
<br><br> 

## 풀이
* 두 부호가 다를 경우에만 버블정렬을 해주면 더욱 쉽게 정렬을 할 수 있다. 만약 데이터가 더욱 커진다면 나의 풀이 방법은 자원을 낭비하는 형태가 될 것이고 복잡해질 것이다.

<br/>
```c++
#include <stdio.h>

int main()
{
//	freopen("input.txt","rt",stdin);
	int num, i, j, res, count;
	int temp[100];
	scanf("%d", &num);
	
	i = 0;
	while (i < num)
	{
		scanf("%d", &temp[i]);
		i++;
	}
	for (i = 0; i < num - 1; i++)
	{
		for (j = 0; j < num - i - 1; j++)
		{
			if (temp[j] > 0 && temp[j + 1] < 0)
			{
				res = temp[j];
				temp[j] = temp[j + 1];
				temp[j + 1] = res;
			}
		}
	}
	for (i = 0; i < num; i++)
		printf("%d ", temp[i]);
	return (0);
}


```
