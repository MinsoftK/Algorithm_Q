# 70. 그래프 최단거리(BFS)

* 다음 그래프에서 1번 정점에서 각 정점으로 가는 최소 이동 간선수를 출력하세요.


![](https://github.com/MinsoftK/c-Algorithm_Q/blob/master/img/70.png?raw=true)



<br/>

#### ▣ 입력설명

* 첫째 줄에는 정점의 수 N(1<=N<=20)와 간선의 수 M가 주어진다. 그 다음부터 M줄에 걸쳐 연결정보가 주어진다.


#### ▣ 출력설명

* 1번 정점에서 각 정점으로 가는 최소 간선수를 2번 정점부터 차례대로 출력하세요.



#### ▣ 입력예제 1
6 9
1 3
1 4
2 1
2 5
3 4
4 5
4 6
6 2
6 5





#### ▣ 출력예제 1
2 : 3
3 : 1
4 : 1
5 : 2
6 : 2

<br/>
<br/>


## 내가 짠 코드
*

<br/>

```c++


```


<br><br> 

## 풀이
*  queue 부분 이해하기 BFS 특징?이라고 해야되나 확실히 DFS와는 차이가 있다. 

<br/>

```c++
#include <stdio.h>
#include <vector>
#include <algorithm>
#include <stack>
#include <queue> //큐 자료구조를 쓰기 위한 헤더 
using namespace std;

vector<int> map[30];
int ch[30], dis[30];
int cnt;

int main()
{
	freopen("input.txt", "rt", stdin);
	int n, m, a, b, tmp, i;
	vector<int> map[30];
	queue<int> Q; 
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= m; i++)
	{
		scanf("%d %d", &a, &b);
		map[a].push_back(b);
	}
	ch[1] = 1;
	//BFS 탐색 부분
	Q.push(1);
	while (!Q.empty())
	{
		tmp = Q.front(); //Queue의 제일 앞부분 값
		Q.pop();
		for (i = 0; i < map[tmp].size(); i++)
		{
			if (ch[map[tmp][i]] == 0)
			{
				ch[map[tmp][i]] = 1;
				Q.push(map[tmp][i]);
				dis[map[tmp][i]] = dis[tmp] + 1;
			}
		}
	}
	for (i = 2; i <= n; i++)
	{
		printf("%d : %d\n", i, dis[i]);
	}
	return (0);
}



//69
/*
************ pair 부분 출력파트   ***********
 	for (i = 1; i <= m; i++)
	{
		for(j = 0; j < map[i].size(); j++)
		{
			printf("map[%d][%d] : %d \n", i, map[i][j].first, map[i][j].second);
		}
	}

*********************************************
*/


//36 삽입정렬 
//43, 44 이분검색 응용 
//51 다이나믹 
//56 재귀
//58 이진트리 깊이우선탐색 
//65 STL vector 생성방법 
//66 DFS 인접리스트 (벡터활용) 
//67 DFS 인접행렬 
//68 DFS 가중치 방향그래프 인접리스트 
//69 BFS 이진트리 넓이 우선탐색 
//70 BFS 그래프 최단거리 
```
