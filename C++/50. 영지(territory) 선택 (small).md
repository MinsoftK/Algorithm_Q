# 50. 영지(territory) 선택: (small)

* 세종대왕은 현수에게 현수가 다스릴 수 있는 영지를 하사하기로 했다. 전체 땅은 사각형으로 표시된다. 그 사각형의 땅 중에서 세종대왕이 현수가 다스릴 수 있는 땅의 크기(세로의 길이와 가로의 길이)를 정해주면 전체 땅 중에서 그 크기의 땅의 위치를 현수가 정하면 되는 것이다.
전체 땅은 사각형의 모양의 격자로 되어 있으며, 그 사각형 땅 안에는 많은 오렌지 나무가 심겨져 있다. 현수는 오렌지를 무척 좋아하여 오렌지 나무가 가장 많이 포함되는 지역을 선택하고 싶어 한다. 현수가 얻을 수 있는 영지의 오렌지 나무 최대 개수를 출력하는 프로그램을 작성하세요. 다음과 같은 땅의 정보가 주어지고, 현수가 사받을 크기가, 가로 2, 세로 3의 크기이면 가장 많은 오렌지 나무가 있는지는 총 오렌지 나무의 개수가 16인 3행 4열부터 시작하는 구역이다.



![영지](https://github.com/MinsoftK/c-Algorithm_Q/blob/master/img/50.png?raw=true)
<br/>

위에서 봤을 때 각 칸의 블록의 개수입니다. 정면에서의 높이 정보와 오른쪽 측면에서의 높이 정보가 주어지면 사용할 수 있는 블록의 쵀대 개수를 출력하세요.


#### ▣ 입력설명

* 첫 줄에 H(세로길이)와 W(가로길이)가 입력된다. (5<=H, W<=50) 그 다음 H줄에 걸쳐 각 사각형 지역에 오렌지의 나무 개수(1~9개) 정보가 주어진다. 
그 다음 영지의 크기인 세로길이(1~H)와 가로길이(1~W)가 차례로 입력된다.





#### ▣ 출력설명

* 첫 줄에 현수가 얻을 수 있는 오렌지 나무의 최대 개수를 출력한다.






#### ▣ 입력예제 1
6 7
3 5 1 3 1 3 2
1 2 1 3 1 1 2
1 3 1 5 1 3 4
5 1 1 3 1 3 2
3 1 1 3 1 1 2
1 3 1 3 1 2 2
2 3





#### ▣ 출력예제 1
16


## 내가 짠 코드
* 인덱싱 생각하는 것이 생각보다 까다로웠다. for문을 사용하는 것에 있어서 굉장히 비효율적인 것 같기도 하다.

```c++
#include <stdio.h>
#include <vector>
#include <algorithm>
using namespace std;

int map[51][51];

int Count(int i, int j, int t_h, int t_w)
{
	int m, n, sum = 0;
	for (m = i; m <= i + t_h - 1; m++)
	{
		for (n = j; n <= j + t_w - 1; n++)
		{
			sum += map[m][n];
		}
	}
	return (sum);
}

int main()
{
	freopen("input.txt","rt",stdin);
	int h, w, i, j, sum = 0, tmp = 0;
	int t_h, t_w;
	scanf("%d %d", &h, &w);
	for (i = 1; i <= h; i++)
	{
		for (j = 1; j <= w; j++)
		{
			scanf("%d", &map[i][j]);
		}
	}
	scanf("%d %d", &t_h, &t_w);
	for (i = 0; i <= h - t_h + 1; i++)
	{
		for (j = 0; j <= w - t_w + 1; j++)
		{
			if (sum < (tmp = Count(i, j, t_h, t_w)))
				sum = tmp;
		}
	}
	printf("%d", sum);
	return (0);
}


```
* 풀이도 비슷하다. 4중 for문을 사용했는데 나는 따로 함수를 빼서 작성했고, 풀이에서는 그대로 for문을 또 써서 작성했다. 
<br><br> 

## 풀이
*  
<br/>
```c++


```
