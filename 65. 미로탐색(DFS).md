# 65. 미로탐색(DFS)

* 자연수 N이 주어지면 7*7 격자판 미로를 탈출하는 경로의 가지수를 출력하는 프로그램을 작
성하세요. 출발점은 격자의 (1, 1) 좌표이고, 탈출 도착점은 (7, 7)좌표이다. 격자판의 1은 벽
이고, 0은 통로이다. 격자판의 움직임은 상하좌우로만 움직인다. 미로가 다음과 같다면

![](https://github.com/MinsoftK/c-Algorithm_Q/blob/master/img/65.png?raw=true)

위의 지도에서 출발점에서 도착점까지 갈 수 있는 방법의 수는 8가지이다.



<br/>

#### ▣ 입력설명

* 첫 번째 줄에 자연수 N(1<=N<=20)이 주어집니다.
두 번째 줄부터 격자판 정보가 주어진다.



#### ▣ 출력설명

* 첫 번째 줄에 경로의 가지수를 출력한다.


#### ▣ 입력예제 1
0 0 0 0 0 0 0
0 1 1 1 1 1 0
0 0 0 1 0 0 0
1 1 0 1 0 1 1
1 1 0 0 0 0 1
1 1 0 1 1 0 0
1 0 0 0 0 0 0




#### ▣ 출력예제 1
8


<br/>
<br/>


## 내가 짠 코드
*

<br/>

```c++


```


<br><br> 

## 풀이
*  

<br/>

```c++
#include <stdio.h>
#include <vector>
#include <algorithm>
#include <stack>
using namespace std;

int map[21][21], cnt, ch[21][21];
int n;
int dx[4] = {-1, 0, 1, 0}; // 12시 방향 기준 idx  
int dy[4] = {0, 1, 0 , -1};
void DFS(int x, int y)
{
	int xx, yy;
	if(x == 7 && y == 7)
	{
		cnt++;
	}
	else 
	{
		for (int i = 0; i <= 3; i++)
		{
			xx = x + dx[i]; //만약 이렇게 안하면 코드가 굉장히 길어진다. 
			yy = y + dy[i];
			if (xx < 1 || xx > 7 || yy < 1 || yy > 7) continue; //범위를 벗어나면 다른 경로를 탐색하게 한다. 
			if (map[xx][yy] == 0 && ch[xx][yy] == 0)
			{
				ch[xx][yy] = 1;
				DFS(xx, yy);
				ch[xx][yy] = 0;
			}
		}
	}
}

int main()
{
//	freopen("input.txt", "rt", stdin);
	int i, j;
	for(i = 1; i <= 7; i++)
	{
		for (j = 1; j <= 7; j++)
		{
			scanf("%d", &map[i][j]);
		}
	}
	ch[1][1] = 1;
	DFS(1,1);
	printf("%d", cnt);
	return(0);
}

//36 삽입정렬 
//43, 44 이분검색 응용 
//51 다이나믹 
//56 재귀
//58 이진트리 깊이우선탐색 
//64 경로탐색
//65 미로탐색

```
