# 55. 기차운행(stack응용)


* A도시에서 출발한 기차는 B도시로 도착한다. 그런데 도로 중간에 T자형 교차로가 있어 출발한 기차의 도착 순서를 조정할 수 있다.

![기차](https://github.com/MinsoftK/c-Algorithm_Q/blob/master/img/55.png?raw=true)

교차로에서는 다음과 같은 두 개의 작업을 합니다.
P(push)작업 : A도시에서 오는 기차를 교차로에 넣는다.
O(out)작업 : 교차로에 들어온 가장 최근 기차를 B도시로 보낸다.
만약 2 1 3 기차 번호 순으로 A도시에서 출발하더라도 B도시에는 T교차로를 이용하여 1 2 3
순으로 도착하게 할 수 있습니다.
그 작업 P, P, O, O, P, O순으로 작업을 하면 B도시에 1, 2, 3 순으로 도착합니다. 
1부터 N까지 번호를 가진 기차가 A도시에서 어떤 순으로 출발하든, B도시에 번호순으로 도착
하도록 하는 교차로 작업을 출력합니다. 모든 기차는 교차로에 들어가야만 B도시로 갈 수 있
습니다. 번호순서대로 도착이 불가능하면 impossible 이라고 출력합니다.

<br/>



#### ▣ 입력설명

* 첫 번째 줄에 자연수 N(3<=N<=30)가 주어진다.
두 번째 줄에 A도시에서 출발하는 기차번호순이 차례대로 입력된다.








#### ▣ 출력설명

* 교차로 작업을 순서대로 P와 O로 출력한다.









#### ▣ 입력예제 1
3
2 1 3







#### ▣ 출력예제 1
PPOOPO

<br/>
<br/>


## 내가 짠 코드
* 몇몇 테스트케이스들을 통과하지 못한다. 모든 경우를 고려하지 못하는 알고리즘이였다. 변수들이 굉장히 많은데 그 모든 것들을 해결할 수 없다. 다른 방법을 써야한다.

```c++
#include <stdio.h>
#include <vector>
#include <algorithm>
#include <stack>
using namespace std;

stack<int> s;
int train(int num, int k, int *temp)
{
	int i, min =50, max =0 , tmp;
	for(i = k; i < num; i++)
	{
		if (temp[i] < min)
		{
			min = temp[i]; 
			tmp = i;	
		}
	}

	for (i = k; i <= tmp; i++)
	{
		s.push(temp[i]);
		printf("P");
	}
	for (i = k; i <= tmp; i++)
	{
		s.pop();
		printf("O");
	}
	return tmp + 1;
}

int main()
{
	freopen("input.txt", "rt", stdin);
	int num, i, min = 50, tmp;
	int temp[31];
	
	scanf("%d", &num);
	for(i = 0; i < num; i++)
		scanf("%d", &temp[i]);
	tmp = 0;
	while(num > tmp) 
	{
		tmp = train(num, tmp, temp);
	}
	return (0);
}



//36 삽입정렬 
//43, 44 이분검색 응용 
//51 다이나믹 

```

### 설명 듣고나서 짠 것
* impossible을 출력하기 위해 배열에 값을 저장했다.

```c++
#include <stdio.h>
#include <vector>
#include <algorithm>
#include <stack>
using namespace std;

int main()
{
//	freopen("input.txt", "rt", stdin);
	int num, i, j, k, tmp;
	int train[31];
	char res[1000];
	stack<int> s;
	
	scanf("%d", &num);
	for(i = 0; i < num; i++)
	{
		scanf("%d", &train[i]);
	}
	vector<int> temp(num);

	for(i = 0; i < num; i++)
	{
		temp[i] = train[i];
	}			
	sort(temp.begin(),temp.end());
	i = 0;
	j = 0;
	k = 0;
	while(i < num)
	{
		s.push(train[i]);
		res[k] = 'P';
		k++;
		while (1)
		{
			if (s.top() == temp[j])
			{
				s.pop();
				res[k] = 'O';
				j++;
				k++;
			}
			else break;
			if (s.empty())
				break;
		}
		i++;
	}
	res[k] = '\0';
	if (!s.empty())
	{
		printf("impossible");
		return (0);
	}
	for (i = 0; res[i] != '\0'; i++)
		printf("%c", res[i]);
	return (0);
}



//36 삽입정렬 
//43, 44 이분검색 응용 
//51 다이나믹 
```


<br><br> 

## 풀이
* 한문자를 받았을때 처리하게 하는 것이 신기하다.... 벡턷 제대로 활용해야겠다. 
또한 사실 배열이 필요하지 않다. 1부터 시작하므로 j++되면서 배열값을 비교하게 돼 있다.

<br/>

```c++
#include <stdio.h>
#include <vector>
#include <algorithm>
#include <stack>
using namespace std;

int main()
{
//	freopen("input.txt", "rt", stdin);
	int num, i, j = 1, n, m, tmp;
	int train[31];
	char res[1000];
	stack<int> s;
	
	scanf("%d", &num);
	for(i = 0; i < num; i++)
	{
		scanf("%d", &train[i]);
	}
	vector<int> temp(num);
	for (i = 1; i <= n; i++)
	{
		temp[i] = i;
	}
	vector<char> res;
	for (i = 1; i <= n; i++)
	{
		scanf("%d", &m);
		s.push(m);
		res.push_back('P');
		while (1)
		{
			if (s.empty()) break;
			if (temp[j] == s.top())
			{
				s.pop();
				j++;
				res.push_back('O');
			}
			else break;
		}
	}
	if (!s.empty())
		printf("impossible\n");
	else
	{
		for (i = 0; i < res.size(); i++) //res에 10개 들어가면 size는 10이됨
			printf("%c", res[i]); 
	}
	return (0);
}



//36 삽입정렬 
//43, 44 이분검색 응용 
//51 다이나믹 


```
