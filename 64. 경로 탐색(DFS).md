# 64. 경로 탐색(DFS)

* 방향그래프가 주어지면 1번 정점에서 N번 정점으로 가는 모든 경로의 가지 수를 출력하는 프
로그램을 작성하세요. 아래 그래프에서 1번 정점에서 5번 정점으로 가는 가지 수는
![](https://github.com/MinsoftK/c-Algorithm_Q/blob/master/img/64.png?raw=true)

총 6 가지입니다. 



<br/>

#### ▣ 입력설명

* 첫째 줄에는 정점의 수 N(1<=N<=20)와 간선의 수 M가 주어진다. 그 다음부터 M줄에 걸쳐 연
결정보가 주어진다.


#### ▣ 출력설명

* 총 가지수를 출력한다.


#### ▣ 입력예제 1
6 9
1 2 7
1 3 4
2 1 2
2 3 5
2 5 5
3 4 5
4 2 2
4 5 5
6 4 5 



#### ▣ 출력예제 1
6

<br/>
<br/>


## 내가 짠 코드
* 탐색 부분에서 map의 idx가 존재하는 경우의 DFS(i) 재귀 부분 생각이 까다로웠다. 탐색을 한 노드는 ch[i] 로 check를 해줘야 하고, 재귀로 들어가고 나서는 ch[i] = 0으로 check를 해제해줘야 한다.

<br/>

```c++
#include <stdio.h>
#include <vector>
#include <algorithm>
#include <stack>
using namespace std;

int map[50][50], ch[30], cnt = 0;
int n;
void DFS(int L)
{
	int i;
	if (L == n)
	{
		cnt++;
	}
	else
	{
		for (i = 1; i <= n; i++)
		{
			if (map[L][i] == 1 && ch[i] == 0)
			{
				ch[i] = 1;
				DFS(i);
				ch[i] = 0;//체크를 푸는 이유는?
				//만약에 1->2->5 cnt++ 한후에
				//2->3 경우를 생각해야된다. 그런데 1->2->->3->4->->5
				//에서 ch[5] = 1 설정이 돼 있기 때문에 갈 수가 없다. 
				// 따라서 ch[i] = 0을 꼭 해줘야 한다. 
			}
		} 
	}
}

int main()
{
//	freopen("input.txt", "rt", stdin);
	int i, j;
	int tmp_i, tmp_j, line;

	scanf("%d %d", &n, &line);
	for(i = 1; i <= line; i++)
	{
		scanf("%d %d", &tmp_i, &tmp_j);
		map[tmp_i][tmp_j] = 1;
	}
	ch[1] = 1;
	DFS(1);
	printf("%d", cnt);
	return(0);
}

//36 삽입정렬 
//43, 44 이분검색 응용 
//51 다이나믹 
//56 재귀
//58 이진트리 깊이우선탐색 


```


<br><br> 

## 풀이
*  

<br/>

```c++


```
