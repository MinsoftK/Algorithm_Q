# 68. 최소비용(DFS 가중치 방향그래프 인접리스트)

* 아래 그림과 같은 이진트리를 넓이우선탐색해 보세요. 간선 정보 6개를 입력받아 처리해보세요.

![](https://github.com/MinsoftK/c-Algorithm_Q/blob/master/img/69.png?raw=true)

넓이 우선 탐색 : 1 2 3 4 5 6 7



<br/>



#### ▣ 입력예제 1
1 2
1 3
2 4
2 5
3 6
3 7





#### ▣ 출력예제 1
1 2 3 4 5 6 7 

<br/>
<br/>


## 내가 짠 코드
*

<br/>

```c++


```


<br><br> 

## 풀이
*  

<br/>

```c++
#include <stdio.h>
#include <vector>
#include <algorithm>
#include <stack>
#define	x first
#define	y second
// first 와 second를 생략하기 위해서 x, y로 정의한다. 
using namespace std;

int n;
vector<pair<int, int> > map[30];
int ch[30], cost = 2147000000;
void DFS(int L, int sum)
{
	int i;
	if (L == n)
	{
		if (cost > sum)
			cost = sum;
	}
	else
	{
		for (i = 0; i < map[L].size(); i++)
		{
			if (ch[map[L][i].first] == 0)
			{
				ch[map[L][i].first] = 1;
//				DFS(map[L][i].first, sum + map[L][i].second);
				DFS(map[L][i].x, sum + map[L][i].y);
				ch[map[L][i].first] = 0;
			}
		}
	}
}

int main()
{
	/*
	pait<int, int> p;
	p = make_pair(10, 20);
	printf("%d %d\n", p.first, p.second);
	*/
	freopen("input.txt", "rt", stdin);
	int i, j, m;
	int a,b,c;
	scanf("%d %d", &n, &m);
	for (i = 1; i <= m; i++)
	{
		scanf("%d %d %d", &a, &b, &c);
		//map[a].push_back({b, c});
		map[a].push_back(make_pair(b, c));
	}
	ch[1] = 1;
	DFS(1, 0);
	printf("%d", cost);
	return(0);
}
/*
************ pair 부분 출력파트   ***********
 	for (i = 1; i <= m; i++)
	{
		for(j = 0; j < map[i].size(); j++)
		{
			printf("map[%d][%d] : %d \n", i, map[i][j].first, map[i][j].second);
		}
	}

*********************************************
*/


//36 삽입정렬 
//43, 44 이분검색 응용 
//51 다이나믹 
//56 재귀
//58 이진트리 깊이우선탐색 


```
