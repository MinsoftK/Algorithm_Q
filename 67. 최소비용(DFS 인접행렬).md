# 67. 최소비용(DFS 인접행렬)

* 가중치 방향그래프가 주어지면 1번 정점에서 N번 정점으로 가는 최소비용을 출력하는 프로그램을 작성하세요.

![](https://github.com/MinsoftK/c-Algorithm_Q/blob/master/img/67.png?raw=true)

총 6 가지입니다. 



<br/>

#### ▣ 입력설명

* 첫째 줄에는 정점의 수 N(1<=N<=20)와 간선의 수 M가 주어진다. 그 다음부터 M줄에 걸쳐 연 결정보가 주어진다.



#### ▣ 출력설명

* 최소비용을 출력합니다.


#### ▣ 입력예제 1
5 8
1 2 12
1 3 6
1 4 10
2 3 2
2 5 2
3 4 3
4 2 2
4 5 5



#### ▣ 출력예제 1
13

<br/>
<br/>


## 내가 짠 코드
*

<br/>

```c++


```


<br><br> 

## 풀이
* 이전 문제들과 비슷하다.

<br/>

```c++
#include <stdio.h>
#include <vector>
#include <algorithm>
#include <stack>
using namespace std;

int n, cost = 2147000000;
int ch[30];
int map[30][30]; 

void DFS(int L, int sum)
{
	int i;
	if (L == n)
	{
		if (sum < cost)
			cost = sum;
	}
	else
	{
		for (i = 1; i <= n; i++)
		{
			if (map[L][i] > 0 && ch[i] == 0) //해당 노드의 값이 0이냐 
			{
				ch[i] = 1;
				DFS(i, sum + map[L][i]);
				ch[i] = 0;	
			}
		}
	}
}

int main()
{
//	freopen("input.txt", "rt", stdin);
	int m, i, tmp_a, tmp_b, tmp_c;
	scanf("%d %d", &n, &m);
	for (i = 1; i <= m; i++)
	{
		scanf("%d %d %d", &tmp_a, &tmp_b, &tmp_c);
		map[tmp_a][tmp_b] = tmp_c;
	}
	ch[1] = 1;
	DFS(1, 0);
	printf("%d", cost);
	return(0);
}

//36 삽입정렬 
//43, 44 이분검색 응용 
//51 다이나믹 
//56 재귀
//58 이진트리 깊이우선탐색 


```
