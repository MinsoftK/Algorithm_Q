# 75. 최대 수입 스케쥴 (Priority_Queue응용)

* 현수는 유명한 강연자이다. N개이 기업에서 강연 요청을 해왔다. 각 기업은 D일 안에 와서 강연을 해 주면 M만큼의 강연료를 주기로 했다.
각 기업이 요청한 D와 M를 바탕으로 가장 많을 돈을 벌 수 있도록 강연 스케쥴을 짜야 한다. 
단 강연의 특성상 현수는 하루에 하나의 기업에서만 강연을 할 수 있다.



<br/>
<br/>

#### ▣ 입력설명

* 첫 번째 줄에 자연수 N(1<=N<=10,000)이 주어지고, 다음 N개의 줄에 M(1<=M<=10,000)과 D(1<=D<=10,000)가 차례로 주어진다.


#### ▣ 출력설명

* 첫 번째 줄에 최대로 벌 수 있는 수입을 출력한다.




#### ▣ 입력예제 1
6
50 2
20 1
40 2
60 3
30 3
30 1





#### ▣ 출력예제 1
150

<br/>
<br/>


## 내가 짠 코드
*

<br/>

```c++


```


<br><br> 

## 풀이
* 
<br/>

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;

struct S
{
	int m,d;
	S(int a, int b)
	{
		m = a;
		d = b;
	}
	bool operator<(S &s)const
	{
		return (d > s.d);
	}
};

int main()
{
	freopen("input.txt", "rt", stdin);	
	int n, i, j, a, b, sum = 0, max = -2147000000;
	vector<S> temp;
	priority_queue<int> pQ;
	scanf("%d", &n);
	for(i = 1; i <= n; i++)
	{
		scanf("%d %d", &a, &b);
		temp.push_back(S(a, b));
		if(b > max) //날짜중에 가장 큰 값을 찾자. 
			max = b; //마지막 강연할 날짜
	}
	sort(temp.begin(),temp.end());
	j = 0; //for문에서 j가 초기화 되버리면 안된다. 따라서 조건을 밖으로 빼줌. 
	for (i = max; i >= 1; i--)
	{
		for ( ; j < n; j++)
		{
			if (temp[j].d < i) break;
			pQ.push(temp[j].m);
		}
		if (!pQ.empty())
		{
			sum += pQ.top();
			pQ.pop();
		}
	} 
	printf("%d", sum);
}



//69
/*
************ pair 부분 출력파트   ***********
 	for (i = 1; i <= m; i++)
	{
		for(j = 0; j < map[i].size(); j++)
		{
			printf("map[%d][%d] : %d \n", i, map[i][j].first, map[i][j].second);
		}
	}

*********************************************
*/

//36 삽입정렬 
//43, 44 이분검색 응용 
//51 다이나믹 
//56 재귀
//58 이진트리 깊이우선탐색 
//65 STL vector 생성방법 
//66 DFS 인접리스트 (벡터활용) 
//67 DFS 인접행렬 
//68 DFS 가중치 방향그래프 인접리스트 
//69 BFS 이진트리 넓이 우선탐색 
//70 BFS 그래프 최단거리 
//71 BFS 상태트리 검색 
//72 최대 Heap 구조와 유사하게 운영이되는  Priority_queue
//75 최대 수입 스케쥴 
```
