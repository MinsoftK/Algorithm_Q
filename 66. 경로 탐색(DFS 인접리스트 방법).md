# 64. 경로 탐색(DFS)

* 방향그래프가 주어지면 1번 정점에서 N번 정점으로 가는 모든 경로의 가지 수를 출력하는 프
로그램을 작성하세요. 아래 그래프에서 1번 정점에서 5번 정점으로 가는 가지 수는 

![](https://github.com/MinsoftK/c-Algorithm_Q/blob/master/img/66.png?raw=true)

총 6 가지입니다. 



<br/>

#### ▣ 입력설명

* 첫째 줄에는 정점의 수 N(1<=N<=20)와 간선의 수 M가 주어진다. 그 다음부터 M줄에 걸쳐 연
결정보가 주어진다.


#### ▣ 출력설명

* 총 가지수를 출력한다.


#### ▣ 입력예제 1
5 9
1 2 
1 3
1 4 
2 1 
2 3 
2 5 
3 4 
4 2 
4 5 




#### ▣ 출력예제 1
6

<br/>
<br/>


## 내가 짠 코드
*

<br/>

```c++


```


<br><br> 

## 풀이
*  

<br/>

```c++
#include <stdio.h>
#include <vector>
#include <algorithm>
#include <stack>
using namespace std;

int n, cnt;
int ch[30];
vector<int> map[30]; 

void DFS(int L)
{
	int i;
	if (L == n)
	{
		cnt++;
	}
	else
	{
		for (i = 0; i < map[L].size(); i++) //size를 활용해 노드 숫자 만큼만 돌린다.
		{
			if (ch[map[L][i]] == 0) //해당 노드의 값이 0이냐 
			{
				ch[map[L][i]] = 1;
				DFS(map[L][i]);
				ch[map[L][i]] = 0;	
			}
		}
	}
}

int main()
{
//	freopen("input.txt", "rt", stdin);
	int m, i, tmp_a, tmp_b;
	scanf("%d %d", &n, &m);
	for (i = 1; i <= m; i++)
	{
		scanf("%d %d", &tmp_a, &tmp_b);
		map[tmp_a].push_back(tmp_b); //map 배열을 vector를 활용해 만들 수 있다.
		//만약 10만개라고 하면 배열로 만든다면 map[100000000][100000000]가 되는데 for문에서 i가 1부터 백만까지 돌아야 한다. 
		//인접리스트로 만들게 된다면 해당 인덱스와 연결된 노드까지만 돌리면 된다. 즉 해당 값이 들어가 있으니 check할 필요없이 돌리면 된다. 
		//size를 활용한다. 
	}
	ch[1] = 1;
	DFS(1);
	printf("%d", cnt);
	return(0);
}

//36 삽입정렬 
//43, 44 이분검색 응용 
//51 다이나믹 
//56 재귀
//58 이진트리 깊이우선탐색 
//65 STL vector 생성방법 
//66 DFS 인접리스트 (벡터활용) 
```
