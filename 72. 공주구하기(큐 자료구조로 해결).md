# 72. 공주구하기(큐 자료구조로 해결)

* 정보 왕국의 이웃 나라 외동딸 공주가 숲속의 괴물에게 잡혀갔습니다. 정보 왕국에는 왕자가 N명이 있는데 서로 공주를 구하러 가겠다고 합니다. 정보왕국의 왕은 다음과 같은 방법으로 공주를 구하러 갈 왕자를 결정하기로 했습니다.
왕은 왕자들을 나이 순으로 1번부터 N번까지 차례로 번호를 매긴다. 그리고 1번 왕자부터 N번 왕자까지 순서대로 시계 방향으로 돌아가며 동그랗게 앉게 한다. 그리고 1번 왕자부터 시
계방향으로 돌아가며 1부터 시작하여 번호를 외치게 한다. 한 왕자가 K(특정숫자)를 외치면 그 왕자는 공주를 구하러 가는데서 제외되고 원 밖으로 나오게 된다. 그리고 다음 왕자부터 다시 
1부터 시작하여 번호를 외친다.이렇게 해서 마지막까지 남은 왕자가 공주를 구하러 갈 수 있다.

![](https://github.com/MinsoftK/c-Algorithm_Q/blob/master/img/72.png?raw=true)




<br/>
<br/>

#### ▣ 입력설명

* 첫 줄에 자연수 N(5<=N<=1,000)과 K(2<=K<=9)가 주어진다.

#### ▣ 출력설명

* 첫 줄에 마지막 남은 왕자의 번호를 출력합니다.



#### ▣ 입력예제 1
6 3 




#### ▣ 출력예제 1
7 

<br/>
<br/>


## 내가 짠 코드
* Heap 구조와 비슷한 우선순위 큐 STL을 이용한다.

<br/>

```c++


```


<br><br> 

## 풀이
*  

<br/>

```c++
#include <stdio.h>
#include <vector>
#include <algorithm>
#include <stack>
#include <queue> //큐 자료구조를 쓰기 위한 헤더 
using namespace std;

int main()
{
//	freopen("input.txt", "rt", stdin);
	int n, i;
	priority_queue<int> pQ;
	while (1)
	{
		scanf("%d", &n);
		if (n == -1)
			break;
		else if (n == 0)
		{
			if (pQ.empty()) printf("-1\n");
			else
			{
				printf("%d\n", pQ.top());	//top가 root 값이다.
				pQ.pop(); 
			}
		}
		else pQ.push(n);
	}
	return (0);
}



//69
/*
************ pair 부분 출력파트   ***********
 	for (i = 1; i <= m; i++)
	{
		for(j = 0; j < map[i].size(); j++)
		{
			printf("map[%d][%d] : %d \n", i, map[i][j].first, map[i][j].second);
		}
	}

*********************************************
*/


//36 삽입정렬 
//43, 44 이분검색 응용 
//51 다이나믹 
//56 재귀
//58 이진트리 깊이우선탐색 
//65 STL vector 생성방법 
//66 DFS 인접리스트 (벡터활용) 
//67 DFS 인접행렬 
//68 DFS 가중치 방향그래프 인접리스트 
//69 BFS 이진트리 넓이 우선탐색 
//70 BFS 그래프 최단거리 
//71 BFS 상태트리 검색 
//72 최대 Heap 구조와 유사하게 운영이되는  Priority_queue 
```
