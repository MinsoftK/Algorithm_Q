# 47. 봉우리

* 지도 정보가 N*N 격자판에 주어집니다. 각 격자에는 그 지역의 높이가 쓰여있습니다. 각 격자판의 숫자 중 자신의 상하좌우 숫자보다 큰 숫자는 봉우리 지역입니다. 봉우리 지역이 몇 개 있는 지 알아내는 프로그램을 작성하세요. 
격자의 가장자리는 0으로 초기화 되었다고 가정한다. 만약 N=5 이고, 격자판의 숫자가 다음과 같다면 봉우리의 개수는 10개입니다.

![봉우리](https://github.com/MinsoftK/c-Algorithm_Q/blob/master/img/47.png?raw=true)


#### ▣ 입력설명

* 첫 줄에 자연수 N이 주어진다.(1<=N<=50) 
두 번째 줄부터 N줄에 걸쳐 각 줄에 N개의 자연수가 주어진다. 각 자연수는 100을 넘지 않는다. 



#### ▣ 출력설명

* 봉우리의 개수를 출력하세요.





#### ▣ 입력예제 1
5
5 3 7 2 3
3 7 1 6 1
7 2 5 3 4
4 3 6 4 1
8 7 3 5 2



#### ▣ 출력예제 1
10



## 내가 짠 코드
* 각각의 left, right, up ,down flag를 만들어 해당 값보다 작을때 flag들을 1로 만들어주고 모든 flag들이 1일 때, 봉우리 cnt++을 해준다. 그리고 for문을 나가기전 모두 0으로 초기화 해준다.
```c++
#include <stdio.h>
#include <vector>
#include <algorithm>
using namespace std;

int map[51][51];
int main()
{
//	freopen("input.txt","rt",stdin);
	int block, i, j, cnt = 0;
	int left = 0, right = 0, up = 0, down = 0;
	scanf("%d", &block);
	for(i = 0; i <= block + 1; i++)
	{
		map[0][i] = 0;
		map[i][0] = 0;
		map[block + 1][i] = 0;
		map[i][block + 1] = 0;
	}
	for(i = 1; i <= block; i++)
	{
		for (j = 1; j <= block; j++)
		{
			scanf("%d", &map[i][j]);
		}
	}
	for(i = 1; i <= block; i++)
	{
		for (j = 1; j <= block; j++)
		{
			if (map[i][j] > map[i][j - 1])
				left = 1;
			if (map[i][j] > map[i][j + 1])
				right = 1;
			if (map[i][j] > map[i - 1][j])
				up = 1;
			if (map[i][j] > map[i + 1][j])
				down = 1;
			if (left && right && up && down)
				cnt++;
			left = 0;
			right = 0;
			up = 0;
			down = 0;
		}
	}
	printf( "%d", cnt);
/*	
	for(i = 1; i <= block; i++)
	{
		for (j = 1; j <= block; j++)
		{
			printf("map[%d][%d] = %d",i, j,map[i][j]);
		}
		printf("\n");
	}
*/
	return (0);
}


```
* 
<br><br> 

## 풀이
* dx, dy를 만들어서 for문을 집어넣어 길이를 줄였다. 코드 줄 수가 굉장히 많이 줄어들었고, 생각대로 0을 가장자리에 입력할 필요는 없었다. 프로그램에서 요구한 것은 봉우리의 갯수였기 때문에
<br/>
```c++

#include <stdio.h>
#include <vector>
#include <algorithm>
using namespace std;

int map[51][51];
int dx[4] = {-1, 0, 1, 0};
int dy[4] = {0, 1, 0 , -1};
int main()
{
//	freopen("input.txt","rt",stdin);
	int block, i, j, k, cnt = 0;
	int left = 0, right = 0, up = 0, down = 0;
	scanf("%d", &block);
	for(i = 1; i <= block; i++)
	{
		for (j = 1; j <= block; j++)
		{
			scanf("%d", &map[i][j]);
		}
	}
	for(i = 1; i <= block; i++)
	{
		for (j = 1; j <= block; j++)
		{
			flag = 0;
			for(k = 0; k < 4; k++)
			{
				if (map[i][j] <= map[i + dx[k][j + dy[k]])
				{
					flag = 1;
					break;
				}
			}
			if (flag == 0)
				cnt++;
		}
	}
	printf( "%d", cnt);
	return (0);
}
```
