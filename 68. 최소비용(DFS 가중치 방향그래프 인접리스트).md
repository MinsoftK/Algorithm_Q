# 68. 최소비용(DFS 가중치 방향그래프 인접리스트)

* 가중치 방향그래프가 주어지면 1번 정점에서 N번 정점으로 가는 최소비용을 출력하는 프로그램을 작성하세요.

![](https://github.com/MinsoftK/c-Algorithm_Q/blob/master/img/67.png?raw=true)

총 6 가지입니다. 



<br/>

#### ▣ 입력설명

* 첫째 줄에는 정점의 수 N(1<=N<=20)와 간선의 수 M가 주어진다. 그 다음부터 M줄에 걸쳐 연결정보가 주어진다.


#### ▣ 출력설명

* 최소비용을 출력합니다.


#### ▣ 입력예제 1
5 8
1 2 12
1 3 6
1 4 10
2 3 2
2 5 2
3 4 3
4 2 2
4 5 5




#### ▣ 출력예제 1
6

<br/>
<br/>


## 내가 짠 코드
*

<br/>

```c++


```


<br><br> 

## 풀이
*  

<br/>

```c++
#include <stdio.h>
#include <vector>
#include <algorithm>
#include <stack>
#define	x first
#define	y second
// first 와 second를 생략하기 위해서 정의한다. 
using namespace std;

int n;
vector<pair<int, int> > map[30];
int ch[30], cost = 2147000000;
void DFS(int L, int sum)
{
	int i;
	if (L == n)
	{
		if (cost > sum)
			cost = sum;
	}
	else
	{
		for (i = 0; i < map[L].size(); i++)
		{
			if (ch[map[L][i].first] == 0)
			{
				ch[map[L][i].first] = 1;
//				DFS(map[L][i].first, sum + map[L][i].second);
				DFS(map[L][i].x, sum + map[L][i].y);
				ch[map[L][i].first] = 0;
			}
		}
	}
}

int main()
{
	/*
	pait<int, int> p;
	p = make_pair(10, 20);
	printf("%d %d\n", p.first, p.second);
	*/
	freopen("input.txt", "rt", stdin);
	int i, j, m;
	int a,b,c;
	scanf("%d %d", &n, &m);
	for (i = 1; i <= m; i++)
	{
		scanf("%d %d %d", &a, &b, &c);
		//map[a].push_back({b, c});
		map[a].push_back(make_pair(b, c));
	}
	ch[1] = 1;
	DFS(1, 0);
	printf("%d", cost);
	return(0);
}
/*
************ pair 부분 출력파트   ***********
 	for (i = 1; i <= m; i++)
	{
		for(j = 0; j < map[i].size(); j++)
		{
			printf("map[%d][%d] : %d \n", i, map[i][j].first, map[i][j].second);
		}
	}

*********************************************
*/


//36 삽입정렬 
//43, 44 이분검색 응용 
//51 다이나믹 
//56 재귀
//58 이진트리 깊이우선탐색 


```
