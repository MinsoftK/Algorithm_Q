# 79. 원더랜드(Prim MST 알고리즘, 우선순위 큐 활용)

* 자연수 N과 R이 주어지면 서로 다른 N개의 자연수 중 R개를 뽑아 일렬로 나열하는 프로그램을 작성하세요. 




<br/>
<br/>

#### ▣ 입력설명

* 첫 번째 줄에 자연수 N(1<=N<=15)과 R(0<=R<=15)이 주어진다. 단 (N>=R)두 번째 줄에 N개의 서로 다른 자연수가 오름차순으로 주어진다.





#### ▣ 출력설명

* 순열의 각 경우를 아래와 같이 오름차순으로 출력한다. 마지막 줄에 총 개수도 출력한다.



#### ▣ 입력예제 1
4 3
1 3 6 7





#### ▣ 출력예제 1
1 3 6
1 3 7
1 6 3
1 6 7
1 7 3
1 7 6
3 1 6
3 1 7
3 6 1
3 6 7
3 7 1
3 7 6
6 1 3
6 1 7
6 3 1
6 3 7
6 7 1
6 7 3
7 1 3
7 1 6
7 3 1
7 3 6
7 6 1
7 6 3
24


<br/>
<br/>


## 내가 짠 코드
* 

<br/>

```c++


```


<br><br> 

## 풀이
* 59번 DFS의 응용버전 문제. 이번 문제는 정해진 r만큼 출력을 해야되는데 임시 배열을 만들어서 출력을 가능하게 해준다. 생각해보면 당연하지만 처음에 배열을 만드는 생각이 까다롭다.

<br/>

```c++
#include <iostream>
#include <stdio.h>
#include <vector>
using namespace std;

int ch[20], arr[20], res[20];
int n, r, cnt = 0;
int DFS(int L)
{
	if (L == r) //L이 r까지 갔을때 res에 저장된 순열 출력 
	{
		for (int j = 0; j < L; j++)
		{
			printf("%d ", res[j]);
		}
		cnt++;
		printf("\n");
	}
	else //L이 r까지 가지 못한경우 
	{
		for (int i = 0; i < n; i++)
		{
			if (ch[i] == 0) //ch배열이 0일 경우에만 출력한다. 1은 이미 출력중 
			{
				res[L] = arr[i]; //출력할 배열에 arr배열 값을 저장한다. 
				ch[i] = 1;	//ch 배열을 1로 바꿔주고 DFS 재귀를 다시 돈다. 
				DFS(L+1);
				ch[i] = 0;	//재귀가 끝나고 다시 0으로 setting 
			}
		}
	}
}

int main()
{
	freopen("input.txt","rt",stdin);
	int i, temp;
	scanf("%d %d", &n ,&r);
	for (i = 0; i < n; i++)
	{
		cin >> arr[i];
	}
	DFS(0);
	printf("%d", cnt);
	return (0);
} 



/*
************ pair 부분 출력파트   ***********
 	for (i = 1; i <= m; i++)
	{
		for(j = 0; j < map[i].size(); j++)
		{
			printf("map[%d][%d] : %d \n", i, map[i][j].first, map[i][j].second);
		}
	}

*********************************************
*/

//36 삽입정렬 
//43, 44 이분검색 응용 
//51 다이나믹 
//56 재귀
//58 이진트리 깊이우선탐색 
//65 STL vector 생성방법 
//66 DFS 인접리스트 (벡터활용) 즘 
//67 DFS 인접행렬 
//68 DFS 가중치 방향그래프 인접리스트 즘 
//69 BFS 이진트리 넓이 우선탐색 
//70 BFS 그래프 최단거리 
//71 BFS 상태트리 검색 
//72 최대 Heap 구조와 유사하게 운영이되는  Priority_queue
//75 최대 수입 스케쥴
//76 이항계수 메모리제이션 
//77 disjoint-set
//78 크루스칼 알고리즘 트리의 최소비용 최소 스패닝트리에 대하여
//79 Prim MST 알고리즘 최소스패닝 트리, 정점 기준으로 추가해나간다. 반복해볼것
//80 다익스트라 알고리즘
//81 벨만-포드 알고리즘
//82 순열구하기 (DFS : Depth First Search) 
```
